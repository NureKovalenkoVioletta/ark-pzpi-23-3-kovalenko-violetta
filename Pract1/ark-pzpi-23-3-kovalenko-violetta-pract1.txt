Міністерство освіти та науки України


Харківський національний університет радіоелектроніки


Кафедра ПІ


ЗВІТ
з практичної роботи № 1
з дисципліни “Аналіз та рефакторинг коду
на тему:
“Правила оформлення програмного коду. Використання принципів SOLID в Java Spring: чому це робить код підтримуваним”








Виконала:                                                        
ст. гр.  ПЗПІ-23-3                                                                       Коваленко В. О.


Перевірив:
ст. викладач кафедри ПІ                                                        Сокорчук Ігор  Петрович














Харків 2025


1 ІСТОРІЯ ЗМІН
Таблиця 1.1 – Історія змін у звіті
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	15.11.2025
	0.1
	Створено розділ “Завдання”
	2
	17.11.2025
	0.2
	Додано розділ “Опис виконаної роботи”
	3
	20.11.2025
	0.3
	Додано додатки А, Б, В
	4
	24.11.2025
	1.0
	Сформовано фінальний текст звіту згідно з ДСТУ 3008:2015
	________________


2 ЗАВДАННЯ
Відповідно до методичних вказівок до лабораторної роботи необхідно виконати наступні завдання:
* Розробити презентацію на тему “Правила оформлення програмного коду. Використання принципів SOLID в Java Spring: чому це робить код підтримуваним” -  у вигляді презентації з поясненнями та прикладами.
* Реалізувати і продемонструвати приклади коду (Java + Spring)
* Продемонструвати реалізацію поганої практики коду та хорошої
* Показати та пояснити інструменти Spring, які використовуються для впровадження принципів SOLID укоді:
________________
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
Під час створення презентації я детально розібралася з тим, як оформлення програмного коду впливає на якість розробки для проєктів, написаних на Java Spring з використанням принципів SOLID. У ході презентації я пояснила, що SOLID – це практичні принципи, завдяки яким код стає більш передбачуваним, легше читається і не перетворюється з часом на незрозумілу систему. Я переконалась, що грамотне застосування SOLID дозволяє спростити масштабування проєкту, зменшити кількість помилок і зробити архітектуру більш логічною та гнучкою.
3.2 Значення правил оформлення коду
Правильне оформлення програмного коду – це реальна необхідність, без якої неможливо підтримувати проєкт у нормальному стані. Під час підготовки презентації я особливо звернула увагу на те, як сильно стиль коду впливає на роботу всієї команди та на якість продукту. Коли в проєкті немає єдиного підходу до оформлення, це швидко створює хаос. Розробникам стає складніше розуміти логіку один одного, і навіть прості зміни займають набагато більше часу. Усі ці дрібні проблеми поступово накопичуються й призводять до конкретних наслідків:
   1. зниження зрозумілості коду, коли доводиться щоразу витрачати час на “розшифровку” чужих стилів та патернів написання;
ускладнення тестування, оскільки непослідовний код важче ізолювати, перевіряти й відтворювати;
   2. зростання технічного боргу, коли замість додавання нового функціоналу доводиться виправляти заплутані рішення;
   3. помилки під час інтеграції та рефакторингу, які з’являються через неузгодженість структур і відсутність логічної архітектурної цілісності.
Під час роботи з Java Spring у рамках принципів SOLID я з’ясувала для себе певні інструменти, які допомагають саме в якісній реалізації цих принципів і ось основні з них:
      1. анотації (@Service, @Repository, @Controller) – вони визначають ролі компонентів
      2. архітектурні шари – чіткий поділ на контролери, сервіси, репозиторії робить застосунок структурованим і передбачуваним;
      3. механізмів залежностей Dependency Injection – вони дозволяють не створювати жорстко прив’язані класи та зменшують складність коду.
      4. Інтерфейси та їх реалізації – допомагають чітко визначити контракти між компонентами та спрощують підміну реалізацій без зміни клієнтського коду;
      5. Strategy pattern – дозволяє підключати нові алгоритми чи поведінку без змін у вже існуючих класах
Завдяки всьому цьому Spring фактично стимулює розробника дотримуватися якісного оформленя коду. 
3.3 Принципи SOLID у контексті Java Spring
Принципи SOLID – це дуже потужний іструмент для створення чистого, структурованого та якісного коду. Під час виконання практичної роботи я детально розбирала, як ці принципи працюють саме в Java Spring, і як їхнє дотримання допомагає уникати незрозумілого та неякісного коду. У Spring застосування SOLID підкріплюється дуже багатою кількістю інструментів: правильно організовані контролери, сервіси та репозиторії, анотації, DI, інтерфейси та патерни. Саме це допомагає не просто писати код, а писати його якісно та зрозуміло не тільки для себе, а і для всієї команди
3.3.1 Принцип Single Responsibility (SRP)
Принцип Single Responsibility говорить про те, що кожен клас повинен виконувати лише одну конкретну задачу і мати лише одну причину для змін. У Spring така поведінка досягається завдяки поділу проєкту на три основні шари:
      1. Controller відповідає за маршрутизацію, валідацію вхідних даних і делегування задач сервісам;
      2. Service містить бізнес-логіку, де реалізується основна поведінка застосунку;
      3. Repository займається доступом до даних і нічим іншим.
Spring також допомагає дотримуватися SRP завдяки анотаціям @Controller, @Service, @Repository та @Component, які чітко позначають роль кожного класу. Отже, якщо підвести підсумки, то можна сказати, що дотримання цього принципу робить код більш тестованим та зменшує зайву залежність між компонентами. Також зростає якість оформлення самих файлів, оскільки кожен клас, метод чи інший компонент містить у собі тільки одну причину для зміни.
3.3.2 Принцип Open/Closed (OCP)
Принцип Open/Closed говорить нам, що класи повинні бути відкриті для розширення, але закриті для змін. Під час роботи з Java Spring я зрозуміла, що цей принцип дуже допомагає уникати ситуацій, коли ми вимушені багато разів змінювати одні й ті самі класи або методи. Використовуючи цей принцип можна замість того, щоб змінювати існуючий код, додавати нову поведінку через розширення класів або нові реалізації інтерфейсів. У Spring це реалізується завдяки таким інструментам:
      1. Інтерфейси та їх реалізації – кожна нова функція оформлюється у окремому класі, який реалізує потрібний інтерфейс, і старий код залишають без змін;
      2. Strategy pattern дозволяє підключати різні алгоритми чи способи поведінки без змін у базових класах;
      3. Dependency Injection через @Configuration, @Bean, @Qualifier та @Profile – допомагає підключати потрібні реалізації у контексті Spring без редагування існуючих сервісів.
Дотримання цього принципа робить код більш гнучким: коли з’являється новий функціонал, не доводиться ламати вже працюючі компоненти. Це спрощує підтримку проєкту і дозволяє уникати помилок.
3.3.3 Принцип Liskov Substitution 
Принцип Liskov Substitution говорить про те, що будь-яка реалізація інтерфейсу повинна можливо замінювати іншу реалізацію без зміни поведінки системи. Під час роботи з Java Spring я побачила, що дотримання цього принципу дуже полегшує роботу з компонентами та їхніми залежностями один з одним  У Spring цей принцип реалізується завдяки таким інструментам:
      1. Інтерфейси та окремі реалізації, дозволяють чітко розділити контракти та конкретну поведінку;
      2. Іін’єкція залежностей дає змогу підмінювати сервіси без змін у клієнтському коді;
      3. Керування реалізаціями через @Qualifier і @Profile допомагає точно вказати, який компонент використовувати у конкретному контексті або середовищі.
Дотримання LSP дозволяє легко підмінювати компоненти, тож коли всі сервіси і класи дотримуються цього принципу, проєкт стає більш гнучким і безпечним при внесенні змін або додаванні нового функціоналу.
3.3.4 Принцип Interface Segregation (ISP)
Принцип Interface Segregation говорить про те, що необхідно розділяти великі універсальні інтерфейси на маленькі, вузькі та спеціалізовані, щоб кожен клієнт залежав лише від того, що йому дійсно потрібно. Під час роботи з Java Spring я побачила, що цей принцип допомагає уникнути «жирних» класів і непотрібної логіки У Spring ISP реалізується через:
      1. Використання окремих інтерфейсів для різних видів поведінки
      2. Позначення реалізацій анотаціями (@Service, @Repository, @Component), бо це допомагає швидко орієнтуватися, який клас за що відповідає;
      3. Ін’єкцію лише необхідних залежностей 
      4. Делегацію замість великих багатозадачних сервісів, коли логіка розділяється на маленькі сервіси

Завдяки дотриманню ISP структура коду стає зрозумілою, компоненти легко підмінювати, а Spring-контейнер дозволяє гнучко керувати залежностями. 
3.4.5 Принцип Dependency Inversion (DIP)
Принцип Dependency Inversion (DIP) говорить про те, що класи повинні залежати від абстракцій, а не від конкретних реалізацій. Під час роботи з Java Spring я помітила, що дотримання цього принципу значно спрощує структуру коду і робить проєкт більш гнучким. У Spring DIP реалізується за допомогою певних інструментів:
         1. Використання інтерфейсів – клієнти працюють через контракти, а не конкретні класи;
         2. Dependency Injection через @Autowired, @Inject або @RequiredArgsConstructor 
         3. Конфігураційні класи @Configuration та бін-компоненти @Bean, вони дозволяють налаштовувати, які реалізації підключаються у проєкті, без змін у клієнтському коді;
         4. IoC-контейнер Spring, який керує життєвим циклом компонентів і вирішує, що та коли підключати.
Дотримання DIP зменшує зв’язність між компонентами, робить код більш гнучким і дозволяє легко підмінювати сервіси та додавати нові функції.
________________


ВИСНОВКИ
У ході виконання практичної роботи було детально проаналізовано значення правил оформлення коду та їхній вплив на підтримуваність програмних систем. Практична робота з принципами SOLID у Java Spring показала, що правильне структурування коду підвищує його читаємість ігнучкість. Дотримання архітектурного поділу на шари, а саме контролери, сервіси, репозиторії, у поєднанні з анотаціями Spring та механізмом Dependency Injection дозволяє зменшити зв’язність між компонентами і спрощує підміну реалізацій через інтерфейси. Застосування кожного з принципів SOLID забезпечує чітку організацію логіки, спрощує масштабування і підтримку проєкту. Таким чином, системне дотримання принципів SOLID та стандартів оформлення коду прямо впливає на стабільність і гнучкість програмних систем у Java Spring.
________________
ВИКОРИСТАНІ ДЖЕРЕЛА
         1. Бранець І. “Чому SOLID - важлива складова мислення програміста. Розбираємося на прикладах з кодом”: https://dou.ua/lenta/articles/solid-principles/ DOU
         2. Анотації Spring та інверсія керування (IoC)  Документація перекладена українською: https://ac2epsilon.github.io/TRANS/SPRING/Spring%205.0.7.html ac2epsilon.github.io
         3. ITVDN. “Новий відео курс SOLID принципи в Java українською мовою” https://itvdn.com/ua/news/article/new-course-solid-java-ua
________________


ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/akGFARr4Zhw
00:00 - Вступ до практичної роботи №1. Тема презентації
00:30 - План презентації
00:54 - Чому важливі правила оформлення коду?
01:42 - Принципи SOLID. Основна ідея та роль у правилах оформлення коду
02:05 - Single Responsibility Principle. Вступне пояснення та основна ідея
02:31 - Single Responsibility Principle. Розглядаємо інструменти реалізації та технічні нюанси
03:26 - Single Responsibility Principle. Практична частина, розглядаємо гарний код і поганий
04:48 - Open/Closed Principle. Розглядаємо основну ідею принципа
05:10 - Open/Closed Principle у Java Spring. Технічні нюанси та інструменти для реалізації
05:52 -  Open/Closed Principle. Розбираємо на практиці гарний та поганий код
06:48 - Liskov Substitution Principle. Загальні ідеї та необхідність принципа при розробці
07:14 - Liskov Substitution Principle. Чистий код через підміну реалізацій у рамках Java Spring
07:43 -  Liskov Substitution Principle. Розбираємо поганий та гарний код на практиці
09:10 - Вступ до Interface Segregation Principle. Основна ідея
09:41 - Реалізація та нюанси Interface Segregation Principle у Java Spring
10:12 - Interface Segregation Principle. Розбираємо поганий приклад коду і гарний
11:22 - Dependency Inversion Principle.  Вступне пояснення та основна ідея
11:47 - Dependency Inversion Principle. Оформлюємо код правильно, використовуючи інструменти Java Spring
12:45 - Dependency Inversion Principle. Практична частина, розглядаємо гарний код і поганий
13:47 - Підсумок використання SOLID у Java Spring в рамках оформлення та структурування коду
14:13 - Дякую за увагу!
________________
ДОДАТОК Б
Графічні матеріали
  

Рисунок Б.1 – Титульний слайд презентації


  

Рисунок Б.2 –  План презентації


  

Рисунок Б.3 – “Чому важливі правила оформлення коду”


  

Рисунок Б.4 – Принципи SOLID


  

 Рисунок Б.5 – Single Responsibility Principle, вступна частина


  

 Рисунок Б.6 – Single Responsibility Principle, нюанси та реалізація


  

 Рисунок Б.7 – Single Responsibility Principle, гарний / поганий код


  

 Рисунок Б.8 – Open/Closed Principle, вступна частина


  

 Рисунок Б.9 – Open/Closed Principle, реалізація та нюанси


  

 Рисунок Б.10 – Open/Closed Principle, гарний / поганий код


  
 Рисунок Б.11 – Liskov Substitution Principle, вступна частина


  
 Рисунок Б.12 – Liskov Substitution Principle, нюанси та реалізація


  

Рисунок Б.13 – Liskov Substitution Principle, гарний / поганий код


  

 Рисунок Б.14  – Interface Segregation Principle, вступна частина


  

 Рисунок Б.15 – Interface Segregation Principle,нюанси та реалізація


  

 Рисунок Б.16 – Interface Segregation Principle, гарний / поганий код


  

 Рисунок Б.17 – Dependency Inversion Principle, вступна частина


  

 Рисунок Б.18 – Dependency Inversion Principle, нюанси та реалізація


  

 Рисунок Б.19 – Dependency Inversion Principle, поганий / гарний код


  

 Рисунок Б.20 – Підсумок використання SOLID у Java Spring


  

 Рисунок Б.21 – Фінальний слайд  “Дякую за увагу”
________________


ДОДАТОК В
Програмний код
В.1 Приклад поганого коду без використання Single Responsibility Principle


 1 @RestController
 2 @RequestMapping("/api/users")
 3 public class BadUserController {
 4 
 5     @PostMapping
 6     public User crt(@RequestBody UserDto dto) {
 7 
 8          @Autowired
 9          private UserRepository repo;
10 
11         if (dto == null || dto.getUsername() == null || dto.getUsername().isBlank()) {
12             throw new RuntimeException("Invalid username");
13         }
14         if (dto.getPassword() == null || dto.getPassword().length() < 6) {
15             throw new RuntimeException("Password too short");
16         }
17 
18         User user = new User();
19         user.setUsername(dto.getUsername().trim());
20         user.setEmail(dto.getEmail() != null ? dto.getEmail().trim() : null);
21         user.setPasswordHash(hash(dto.getPassword()));
22 
23         User saved = repo.save(user);
24         sendEmail(user.getEmail(), "Welcome " + user.getUsername() + "!");
25 
26         return user;
27     }
28 }






В.2 Приклад гарного коду з використанням Single Responsibility Principle


 1 @RestController
 2 @RequestMapping("/api/users")
 3 @RequiredArgsConstructor
 4 public class UserController {
 5     private final UserService service;
 6 
 7     @PostMapping
 8     public UserDto create(@RequestBody CreateUserRequest req) {
 9         return service.create(req);
10     }
11 }
12 
13 @Service
14 @RequiredArgsConstructor
15 public class UserService {
16     private final UserRepository repo;
17     private final PasswordEncoder encoder;
18     private final EmailNotifier notifier;
19 
20     public UserDto create(CreateUserRequest req) {
21         User user = new User(req.getUsername(), req.getEmail(), encoder.encode(req.getPassword()));
22         User saved = repo.save(user);
23         notifier.sendWelcome(saved.getEmail());
24         return new UserDto(saved.getUsername(), saved.getEmail());
25     }
26 }
27 
28 @Component
29 public class EmailNotifier {
30     public void sendWelcome(String email) {
31         System.out.println("Welcome email sent to " + email);
32     }
33 }
34 
35 public interface UserRepository {
36     User save(User user);
37 }




В.3 Приклад поганого коду без використання Open/Closed Principle
1  @Service
2  public class PaymentService {
3      public void processCreditCardPayment() { ... }
4      public void processPayPalPayment() { ... }
5      public void processBitcoinPayment() { ... }
6  }


В.4 Приклад гарного коду з використанням Open/Closed Principle


1  public interface PaymentStrategy {
2      void pay(Order order);
3  }
4  
5  @Service
6  @Qualifier("creditCard")
7  public class CreditCardPayment implements PaymentStrategy {
8      public void pay(Order order) { ... }
9  }
10 
11 @Service
12 @Qualifier("paypal")
13 public class PayPalPayment implements PaymentStrategy {
14     public void pay(Order order) { ... }
15 }
16 
17 @Service
18 public class PaymentProcessor {
19     private final Map<String, PaymentStrategy> strategies;
20 
21     public PaymentProcessor(List<PaymentStrategy> strategyList) {
22         strategies = strategyList.stream()
23                                  .collect(Collectors.toMap(
24                                      s -> s.getClass().getSimpleName().toLowerCase(),
25                                      s -> s));
26     }
27 
28     public void processPayment(String type, Order order) {
29         strategies.get(type.toLowerCase()).pay(order);
30     }
31 }


В.5 Приклад поганого коду без використання Liskov Substitution Principle
1  @Service
2  public class NotificationManager {
3
4      public void sendEmail(String to, String message) {
5          // логіка відправки email
6      }
7
8      public void sendSms(String phone, String message) {
9          // логіка відправки sms
10     }
11
12     public void sendPush(String deviceToken, String message) {
13         // логіка відправки push
14     }
15 }


В.6 Приклад гарного коду з використанням Liskov Substitution Principle


 1  public interface NotificationService {
 2      void send(String recipient, String message);
 3  }
 4
 5  @Service
 6  @Qualifier("email")
 7  public class EmailNotificationService implements NotificationService {
 8      @Override
 9      public void send(String recipient, String message) {
10          // логіка відправки email
11      }
12  }
13
14  @Service
15  @Qualifier("sms")
16  public class SmsNotificationService implements NotificationService {
17      @Override
18      public void send(String recipient, String message) {
19          // логіка відправки sms
20      }
21  }
22
23  @Service
24  @Qualifier("push")
25  public class PushNotificationService implements NotificationService {
26      @Override
27      public void send(String recipient, String message) {
28          // логіка відправки push
29      }
30  }
31
32  @Component
33  public class NotificationClient {
34      private final NotificationService notificationService;
35
36      @Autowired
37      public NotificationClient(@Qualifier("email") NotificationService notificationService) {
38          this.notificationService = notificationService;
39      }
40
41      public void notifyUser(String recipient, String message) {
42          notificationService.send(recipient, message);
43      }
44  }


В.7 Приклад поганого коду без використання Interface Segregation Principle


 1  public interface PaymentService {
 2      void validatePayment(PaymentRequest req);
 3      void processCardPayment(PaymentRequest req);
 4      void processBankTransfer(PaymentRequest req);
 5      void processMobilePay(PaymentRequest req);
 6      void recordTransaction(PaymentRequest req);
 7      void notifyUser(String userId, String message);
 8  }
 9
10  @Service
11  public class PaymentServiceImpl implements PaymentService {
12
13      @Override
14      public void validatePayment(PaymentRequest req) {
15          // валідація
16      }
17
18      @Override
19      public void processCardPayment(PaymentRequest req) {
20          // обробка оплати через картку
21      }
22
23      @Override
24      public void processMobilePay(PaymentRequest req) { 
25          // обробка оплати через мобілку
26      }
27
28      public void recordTransaction(PaymentRequest req) {
29          // збереження даних транзакції у базу   
30      }
31
32      @Override
33      public void notifyUser(String userId, String message) {
34          // відправка повідомлення користувачу
35      }
36  }


В.8 Приклад гарного коду з використанням Interface Segregation Principle


 1  public interface PaymentValidator {
 2      void validate(PaymentRequest req);
 3  }
 4
 5  public interface PaymentProcessor {           
 6      void process(PaymentRequest req);
 7  }
 8
 9  public interface TransactionRecorder {
10      void record(PaymentRequest req);
11  }
12
13  public interface NotificationService {
14      void notifyUser(String userId, String message);
15  }
16
17  @Component
18  public class DefaultPaymentValidator implements PaymentValidator {
19       void validate(PaymentRequest req){
20          // валідація даних
21       }
22  }
23
24  @Service
25  @Qualifier("card")
26  public class CardPaymentProcessor implements PaymentProcessor {
27      void process(PaymentRequest req){
28          // обробка платіжних даних
29      }
30  }
31
32  @Service
33  public class DatabaseTransactionRecorder implements TransactionRecorder {
34      void record(PaymentRequest req){
35          // обробка даних та збереження в базу
36      }
37  }
38
39  @Service
40  public class UserNotificationService implements NotificationService {
41      notifyUser(String userId, String message){
42          // відправка нотифікацій
43      }
44  }
45
46  @Service
47  public class PaymentService {
48
49      private final PaymentValidator validator;
50      private final PaymentProcessor processor;
51      private final TransactionRecorder recorder;
52      private final NotificationService notifier;
53
54      public PaymentService(PaymentValidator validator,
55                            @Qualifier("card") PaymentProcessor processor,
56                            TransactionRecorder recorder,
57                            NotificationService notifier) {
58          this.validator = validator;
59          this.processor = processor;
60          this.recorder = recorder;
61          this.notifier = notifier;
62      }
63
64      public void handlePayment(PaymentRequest req) {
65          validator.validate(req);
66          processor.process(req);
67          recorder.record(req);
68          notifier.notifyUser(req.getUserId(), "Payment completed successfully");
69      }
70  }


В.7 Приклад поганого коду без використання Dependency Inversion Principle


 1  @Service
 2  public class OrderService {
 3
 4      private final PaymentService paymentService = new PaymentService();
 5      private final InventoryService inventoryService = new InventoryService();
 6      private final ShippingService shippingService = new ShippingService();
 7
 8      public void placeOrder(Order order) {
 9          paymentService.processPayment(order);
10          inventoryService.reserveItems(order);
11          shippingService.shipOrder(order);
12      }
13  }


В.8 Приклад гарного коду з використанням Dependency Inversion Principle


 1  public interface PaymentService {
 2      void processPayment(Order order);
 3  }
 4
 5  public interface InventoryService {
 6      void reserveItems(Order order);
 7  }
 8
 9  public interface ShippingService {
10      void shipOrder(Order order);
11  }
12
13  @Service
14  @RequiredArgsConstructor
15  public class OrderService {
16
17      private final PaymentService paymentService;
18      private final InventoryService inventoryService;
19      private final ShippingService shippingService;
20
21      public void placeOrder(Order order) {
22          paymentService.processPayment(order);
23          inventoryService.reserveItems(order);
24          shippingService.shipOrder(order);
25      }
26  }
27
28  @Service
29  public class PaypalPaymentService implements PaymentService {
30      @Override
31      public void processPayment(Order order) {
32
33      }
34  }
35
36  @Service
37  public class WarehouseInventoryService implements InventoryService {
38      @Override
39      public void reserveItems(Order order) {
40
41      }
42  }
43
44  @Service
45  public class FedExShippingService implements ShippingService {
46      @Override
47      public void shipOrder(Order order) {
48          // Логіка доставки FedEx
49      }
50  }
51
52  @Configuration
53  public class AppConfig {
54      @Bean
55      public PaymentService paymentService() {
56          return new PaypalPaymentService();
57      }
58
59      @Bean
60      public InventoryService inventoryService() {
61          return new WarehouseInventoryService();
62      }
63
64      @Bean
65      public ShippingService shippingService() {
66          return new FedExShippingService();
67      }
68  }
