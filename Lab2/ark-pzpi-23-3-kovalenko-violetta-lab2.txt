Міністерство освіти та науки України


Харківський національний університет радіоелектроніки


Кафедра ПІ


ЗВІТ
з лабораторної роботи № 2
з дисципліни “Аналіз та рефакторинг коду
на тему:
“Розробка бази даних для серверної частини системи та прикладного програмного інтерфейсу (API)
”








Виконала:                                                        
ст. гр.  ПЗПІ-23-3                                                                       Коваленко В. О.


Перевірив:
ст. викладач кафедри ПІ                                                        Сокорчук Ігор  Петрович










Харків 2025
________________
1 ІСТОРІЯ ЗМІН
Таблиця 1.1 – Історія змін у звіті
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	06.12.2025
	0.1
	Створено розділ “Завдання”
	2
	12.12.2025
	0.2
	Додано розділ “Опис виконаної роботи”
	3
	14.12.2025
	1.0
	Додано додатки А, Б, В
	________________


2 ЗАВДАННЯ
На лабораторній роботі №2 потрібно розробити базу даних для серверної частини  програмної системи та прикладного програмного інтерфейсу. 
* Розробити будову програмної системи.
* Створити UML діаграму прецедентів для серверної частини системи.
* Створити ER діаграму даних.
* Розробити базу даних (БД) програмної системи.
* Створити діаграму структури БД.
* Розробити функції роботи з БД (ORM або CoRM тощо).
* Розробити API (REST або GraphQL, gRPC тощо) для взаємодії серверної частини з клієнтами.
* Створити специфікацію розробленого API.
* Створити програмну реалізацію розробленого API та функцій роботи з БД.
* Перевірити роботу створеного програмного коду серверної частини системи.


________________


3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
У лабораторній роботі №2 я розробляю серверну частину програмної системи автоматизованих дієт. У межах роботи я зосереджусь на проєктуванні структури системи, моделі даних та бази даних. Спочатку я опишу будову програмної системи, тобто я  визначу основні складові серверної частини та їх призначення. Після цього я створю UML діаграму прецедентів для серверної частини системи, у якій зафіксую доступні дії користувачів і адміністратора відносно серверних функцій. Далі я проєктую модель даних системи. Я розроблю ER діаграму, яка відображає основні сутності, їх атрибути та звʼязки між ними. На основі цієї моделі я створюю базу даних програмної системи та сформую діаграму структури БД з описом таблиць, первинних і зовнішніх ключів. Після створення бази даних я реалізую функції роботи з нею. Для цього я застосую ORM Entity Framework. Наступним етапом я розроблю API для взаємодії серверної частини з клієнтами. Я визначу тип API, REST, перелік ендпоінтів, методи доступу та формат передавання даних. Для розробленого API я створю специфікацію, у якій опишу структуру запитів і відповідей. На завершальному етапі я виконаю програмну реалізацію API та функцій роботи з базою даних. Я перевірю коректність роботи серверного коду шляхом виконання запитів до API та аналізу результатів. 
3.2 Розробити будову програмної системи.
3.2.1 Будова програмної системи
Програмна система буде побудована за багаторівневою архітектурою, яка дозволяє розділити відповідальність між різними компонентами. Серверна частина буде реалізована на ASP.NET Core Web API з використанням C# і Entity Framework Core. Вона відповідає за всю бізнес-логіку системи, обробку запитів клієнтів і взаємодію з базою даних через сервіси та репозиторії. 
База даних буде побудована на SQL Server і організована таким чином, щоб зберігати дані користувачів, профілів, рецептів, дієтичних планів, телеметричних показників, записів сну та тренувальних сесій. Використовуються різні типи зв’язків між таблицями: «один-до-одного» для пов’язаних профілів, «один-до-багатьох» для зв’язку користувачів із дієтичними планами або пристроями, а також «багато-до-багатьох» для складних зв’язків, наприклад між рецептами та продуктами або між прийомами їжі та рецептами.
3.2.2 Опис моделей та зв’язків
Модель користувача є центральною у системі. Кожен користувач має свій унікальний ідентифікатор, електронну пошту, хеш пароля, мову інтерфейсу та роль. Користувачі безпосередньо не містять всі персональні дані: вони зберігаються у моделі профілю. Кожен профіль пов’язаний з користувачем через зв’язок «один-до-одного», що дозволяє зберігатиперсональні атрибути, такі як ім’я, прізвище, стать, ріст, вага, рівень активності, наявність медичних станів, переважні одиниці вимірювання та дату народження.
Система підтримує шаблони дієт і денні плани.  Шаблон дієти містить базові параметри: назву, опис, цільові значення калорій, білків, жирів і вуглеводів, кількість прийомів їжі та статус шаблону. Шаблони слугують основою для створення індивідуальних денних планів користувачів
Денні плани містять зв’язок із користувачем і з шаблоном дієти. Вони визначають конкретні параметри харчування на день: калорійність, склад макронутрієнтів, кількість прийомів їжі та статус плану. Кожен денний план може містити декілька прийомів їжі
Модель прийому їжі містить інформацію про час прийому, його порядок у денному плані та цільові значення калорійності і макронутрієнтів. Кожен прийом їжі може містити один або кілька рецептів через проміжну таблицю, що реалізує зв’язок багато-до-багатьох. Рецепти включають назву, інструкції приготування, харчову цінність на порцію та список продуктів із кількістю грамів через таблицю.
Модель продуктузберігає харчові дані: калорійність, вміст білків, жирів, вуглеводів на 100 г, можливі обмеження та алергени, а також одиниці вимірювання. Завдяки зв’язку багато-до-багатьох з рецептами, один продукт може входити до декількох рецептів, а рецепт може містити кілька продуктів із зазначенням точної кількості грамів.
Рекомендації надають додаткову інформацію користувачу щодо конкретного прийому їжі або плану харчування. Вони містять тип рекомендації, зміст або параметри для налаштування харчування, а також статус. Кожна рекомендація може бути прив’язана до конкретного прийому їжі 
Система підтримує інтеграцію з фізичними пристроями користувача (фітнес браслет) . Кожен пристрій має тип, спосіб підключення, серійний номер та останній час взаємодії. Пристрої збирають телеметричні дані і записи сну . Телеметрія містить тип показника, час вимірювання та значення, а записи сну включають дані про загальний час сну, глибокий і легкий сон, час пробудження, якість сну та часові рамки. Також підтримуються тренування , які фіксують час початку та завершення, тип та інтенсивність тренування, тривалість та приблизну кількість витрачених калорій.
3.3 Побудова ER-діаграми 
Для створення ER-діаграми я виділила основні сутності: “TemplateDietPlan”, “DailyDietPlan”, “Meal”, “Recipe”, “Product”, “Recommendation”, “User”, “UserProfile”, “Device”, “TelemetrySample”, “SleepRecord», “TrainingSession”. Тепер, для моїх основних сутностей, я визначаю атрибути:
а) Сутність “TemplateDietPlan”: Описує шаблонний план харчування, який може бути використаний для створення щоденних планів. Містить такі атрибути:
1. template_diet_plan_id (PK) – унікальний ідентифікатор шаблонного плану;
2. template_name –  назва плану;
3. template_description – текстовий опис плану;
4. template_calories_min – мінімальна кількість калорій у плані;
5. template_calories_max – максимальна кількість калорій;
6. template_protein_min – мінімальна кількість білків;
7. template_protein_max – максимальна кількість білків;
8. template_fat_min – мінімальна кількість жирів;
9. template_fat_max – максимальна кількість жирів;
10. template_carbs_min – мінімальна кількість вуглеводів;
11. template_carbs_max – максимальна кількість вуглеводів;
12. template_number_of_meals – кількість прийомів їжі в плані;
13. template_status – статус шаблону (активний, архівований тощо);
14. template_created_at – дата створення шаблону.
б) Сутність «DailyDietPlan» Містить сформований щоденний харчовий план для користувача.
1. daily_diet_plan_id (PK) – унікальний ідентифікатор щоденного плану;
2. daily_diet_plan_name – назва плану;
3. daily_plan_description – опис плану;
4. daily_plan_calories – загальна кількість калорій
5. daily_plan_fat – загальна кількість жирів;
6. daily_plan_carbs – загальна кількість вуглеводів;
7. daily_plan_number_of_meals – кількість прийомів їжі в плані;
8. daily_plan_status – статус виконання плану;
9. daily_plan_created_at – дата створення;
в) Сутність “Meal” Містить прийоми їжі у межах DailyDietPlan. Містить тfкі атрибути:
1. meal_id (PK) – унікальний ідентифікатор прийому їжі;
2. meal_time (enum) – час прийому їжі;
3. meal_target_calories – цільові калорії;
4. meal_target_fat – цільові жири;
5. meal_target_carbs – цільові вуглеводи;
6. meal_target_protein – цільові білки;
г) Сутність “Recipe”. Містить рецепти, які можуть використовуватися у прийомах їжі. Містить такі атрибути:
1. recipe_id (PK) – унікальний ідентифікатор рецепта;
2. recipe_instructions – текст інструкцій приготування;
3. recipe_calories_per_portion – калорії в одній порції;
4. recipe_fat_per_portion – жири в порції
5. recipe_carbs_per_portion – вуглеводи в порції;
6. recipe_protein_per_portion – білки в порції;
7. recipe_products_grams – сумарна вага продуктів
д) Сутність “Product”. Містить харчові продукти, що використовуються у рецептах. Містить такі атрибути:
1. product_id (PK) – унікальний ідентифікатор продукту;
2. product_name – назва продукту;
3. calories_per_100g – калорії на 100 г;
4. protein_per_100g – білки на 100 г;
5. fat_per_100g – жири на 100 г;
6. carbs_per_100g – вуглеводи на 100 г;
7. restriction – інформація про обмеження (алергени, несумісність).
е) Сутність “Recommendation” Містить рекомендації користувачу на основі його показників. Містить такі атрибути:
1. recommendation_id (PK) – унікальний ID рекомендації; 
2. recommendation_created_at – дата створення;
3. recommendation_type – тип рекомендації;
4. recommendation_payload – додаткові дані;
5. recommendation_status – статус;
ж) Сутність “User”. Містить дані облікового запису користувача. Містить такі трибути:
1. user_id (PK) – унікальний ідентифікатор користувача;
2. email – електронна пошта;
3. password_hash – хеш пароля;
4. created_at – дата створення акаунта;
5. locale – локалізація;
6. role – роль користувача (user/admin/superAdmin).
з) Сутність “UserProfile”. Містить персональні дані користувача. Містить такі атрибути
1. profile_id (PK) – унікальний ідентифікатор профілю;
2. first_name, last_name – ім’я та прізвище;
3. sex – стать;
4. height_cm – зріст;
5. current_weight_kg – вага;
6. activity_level – рівень активності;
7. medical_conditions – медичні стани;
8. preferred_units – система одиниць;
і) Сутність “Device”. Описує пристрій користувача. Містить такі атрибути:
1. device_id (PK) – унікальний ID пристрою;
2. device_type – тип пристрою;
3. connection_type – спосіб підключення;
4. last_seen – коли останній раз був активний;
5. serial – серійний номер;
й) Сутність “TelemetrySample”. Зберігає точкові дані телеметрії з пристроїв. Містить такі атрибути:
1. sample_id (PK) – унікальний ідентифікатор запису;
2. timestamp – момент вимірювання;
3. telememtry_type (enum) – тип даних;
4. telemetry_value – значення вимірювання;
к) Сутність “SleepRecord”. Зберігає дані про сон користувача. Містить такі атрибути:
1. sleep_id (PK) – унікальний ID запису;
2. date – дата сну;
3. total_sleep_minutes – тривалість сну;
4. deep_sleep_minutes – глибокий сон;
5. light_sleep_minutes – легкий сон;
6. awake_minutes – хвилини пробудження;
7. sleep_quality – якість сну;
8. start_time, end_time – час початку/кінця;
л) Сутність “TrainingSession”. Містить інформацію про тренування користувача.
1. session_id (PK) – унікальний ID тренування;
2. start_time, end_time – час проведення;
3. type (enum) – тип тренування;
4. intensity – інтенсивність;
5. duration_in_min – тривалість;
6. calories_estimated – розраховані калорії;
Також вказуємо відносини між даними сутностями:
а) Зв’язок «DailyDietPlan» та «Meal»
1. зв'язок: один до багатьох (One-to-Many)
2. опис: один щоденний план харчування може містити багато прийомів їжі, але кожен Meal належить лише одному DailyDietPlan.
б) Зв’язок «Meal» та «Recipe»
1. зв'язок: багато-до-багатьох (Many-to-Many)
2. опис: один прийом їжі може містити багато рецептів, і один рецепт може бути використаний у багатьох прийомах їжі.
в) Зв’язок “Recipe” та “Product” 
1. зв'язок: багато-до-багатьох (Many-to-Many)
2. опис: один рецепт може містити багато продуктів, і один продукт може входити до багатьох різних рецептів.
г) Зв’язок “User” та “DailyDietPlan”
1. зв'язок: один до багатьох (One-to-Many)
2. опис: один користувач може мати багато щоденних планів харчування, але кожен DailyDietPlan належить лише одному User.
д) Зв’язок “Use” та “UserProfile”
1. зв'язок: один до одного (One-to-One)
2. опис: кожен користувач має один профіль, і кожен UserProfile належить лише одному User.
е) Зв’язок “User” та “Device”
1. зв'язок: один до багатьох (One-to-Many)
2. опис: один користувач може мати кілька пристроїв, але кожен Device належить лише одному User.
ж) Зв’язок “Device” та “TelemetrySample”
1. зв'язок: один до багатьох (One-to-Many)
2. опис: один пристрій може записувати багато телеметричних значень, але кожен TelemetrySample походить від конкретного Device.
з) Зв’язок “Device” та “SleepRecord”
1. зв'язок: один до багатьох (One-to-Many)
2. опис: один пристрій може створити багато записів сну, але кожен SleepRecord належить одному Device.
і) Зв’язок “Device” та “TrainingSession”
1. зв'язок: один до багатьох (One-to-Many)
2. опис: один пристрій може фіксувати багато тренувальних сесій, але кожна TrainingSession прив’язана лише до одного Device.
й) Зв’язок “TemplateDietPlan” та “DailyDietPlan”
1. зв'язок: один до багатьох (One-to-Many)
2. опис: один шаблонний план може бути використаний для створення кількох DailyDietPlan, але кожен створений щоденний план базується на одному TemplateDietPlan.
На рисунку 2.1 відображена ER-діаграма 


  

Рисунок 3.1 - ER-діаграма
3.4 Побудова логічної моделі бази даних на базі ER-діаграми
* таблиця “TemplateDietPlan”: первинний ключ (PK) – template_diet_plan_id; зовнішні ключі (FK): відсутні;
* таблиця “DailyDietPlan”: первинний ключ (PK) – daily_diet_plan_id; зовнішні ключі (FK): user_id – посилається на поле user_id у таблиці “User”; template_diet_plan_id – посилається на поле template_diet_plan_id у таблиці “TemplateDietPlan”;
* таблиця “Meal”: первинний ключ (PK) – meal_id; зовнішній ключ (FK): daily_diet_plan_id – посилається на поле daily_diet_plan_id у таблиці “DailyDietPlan”;
* таблиця “Recipe”: первинний ключ (PK) – recipe_id; зовнішні ключі (FK): відсутні;
* таблиця “Product”: первинний ключ (PK) – product_id; зовнішні ключі (FK): відсутні;
* таблиця “Recommendation”: первинний ключ (PK) – uniqueID; зовнішні ключі (FK): відсутні;
* таблиця “User”: первинний ключ (PK) – user_id; зовнішні ключі (FK): відсутні;
*  таблиця “UserProfile”: первинний ключ (PK) – profile_id; зовнішній ключ (FK): user_id – посилається на поле user_id у таблиці “User”;
* таблиця “Device”: первинний ключ (PK) – device_id; зовнішній ключ (FK): user_id – посилається на поле user_id у таблиці “User”;
* таблиця “TelemetrySample”: первинний ключ (PK) – sample_id; зовнішній ключ (FK): device_id – посилається на поле device_id у таблиці “Device”;
* таблиця “SleepRecord”: первинний ключ (PK) – sleep_id; зовнішній ключ (FK): device_id – посилається на поле device_id у таблиці “Device”;
* таблиця “TrainingSession”: первинний ключ (PK) – session_id; зовнішній ключ (FK): device_id – посилається на поле device_id у таблиці “Device”;
* таблиця “MealRecipe”: складений первинний ключ (PK) – meal_id, recipe_id; зовнішні ключі (FK): meal_id – посилається на поле meal_id у таблиці “Meal”; recipe_id – посилається на поле recipe_id у таблиці “Recipe”;
* таблиця “RecipeProduct”: складений первинний ключ (PK) – recipe_id, product_id; зовнішні ключі (FK): recipe_id – посилається на поле recipe_id у таблиці “Recipe”; product_id – посилається на поле product_id у таблиці “Product”.
Тепер можна перейти до проектування схеми реляційної БД. На рисунку 2.2 наведена схема реляційної БД
  

Рисунок 3.2 - Схема реляційної БД
Отримана схема БД повинна бути нормалізованою, отже доречним буде провести перевірку кожної отриманої в схемі таблиці на відповідність вимогам третьої нормальної форми:
а) TemplateDietPlan, визначаємо функціональні залежності:
1. template_diet_plan_id -> template_name, template_description, template_calories_min, template_calories_max, template_protein_min, template_protein_max, template_fat_min, template_fat_max, template_carbs_min, template_carbs_max, template_number_of_meals, template_status, template_created_at;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа template_diet_plan_id і немає транзитивних залежностей;
б) DailyDietPlan, визначаємо функціональні залежності:
1. daily_diet_plan_id -> daily_diet_plan_name, daily_plan_description, daily_plan_calories, daily_plan_fat, daily_plan_carbs, daily_plan_number_of_meals, daily_plan_status, daily_plan_created_at, user_id, template_diet_plan_id;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа daily_diet_plan_id і немає транзитивних залежностей;
в) Meal, визначаємо функціональні залежності:
1. meal_id -> meal_time, meal_target_calories, meal_target_fat, meal_target_carbs, meal_target_protein, daily_diet_plan_id;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа meal_id і немає транзитивних залежностей;
г) Recipe, визначаємо функціональні залежності:
1. recipe_id -> recipe_instructions, recipe_calories_per_portion, recipe_fat_per_portion, recipe_carbs_per_portion, recipe_protein_per_portion, recipe_products_grams;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа recipe_id і немає транзитивних залежностей;
д) Product, визначаємо функціональні залежності:
1. product_id -> product_name, calories_per_100g, protein_per_100g, fat_per_100g, carbs_per_100g, restriction;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа product_id і немає транзитивних залежностей;
е) Recommendation, визначаємо функціональні залежності:
1. recommendation_id -> recommendation_created_at, recommendation_type, recommendation_payload, recommendation_status;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа recommendation_id і немає транзитивних залежностей;
ж) User, визначаємо функціональні залежності:
1. user_id –> email, password_hash, created_at, locale, role;
2. таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа user_id і немає транзитивних залежностей;
з) UserProfile, визначаємо функціональні залежності:
1. profile_id –> first_name, last_name, sex, height_cm, current_weight_kg, activity_level, medical_conditions, preferred_units, user_id;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа profile_id і немає транзитивних залежностей;
і) Device, визначаємо функціональні залежності:
1. device_id –> device_type, connection_type, last_seen, serial, user_id;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа device_id і немає транзитивних залежностей;
й) TelemetrySample, визначаємо функціональні залежності:
1. sample_id –>  timestamp, telememtry_type, telemetry_value, device_id;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа sample_id і немає транзитивних залежностей;
к) SleepRecord, визначаємо функціональні залежності:
1. sleep_id –> date, total_sleep_minutes, deep_sleep_minutes, light_sleep_minutes, awake_minutes, sleep_quality, start_time, end_time, device_id;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа sleep_id і немає транзитивних залежностей;
л) TrainingSession, визначаємо функціональні залежності:
1. session_id –> start_time, end_time, type, intensity, duration_in_min, calories_estimated, device_id;
2. Таблиця знаходиться в 3НФ, тому що всі атрибути залежать від первинного ключа session_id і немає транзитивних залежностей;
м) Meal_Recipe (проміжна таблиця M:N), визначаємо функціональні залежності: 
1. (meal_id, recipe_id) –>  атрибутів окрім ключових немає;
2. Таблиця знаходиться в 3НФ, тому що немає неключових атрибутів і неможливі транзитивні залежності;
н) Recipe_Product (проміжна таблиця M:N), визначаємо функціональні залежності:
1. (recipe_id, product_id) –>  атрибутів окрім ключових немає;
2. Таблиця знаходиться в 3НФ, тому що містить лише складений ключ і не має додаткових атрибутів.
3.5 Побудова логічної моделі бази даних шляхом нормалізації
Я починаю нормалізацію з об’єднання всіх даних у одну велику таблицю, щоб побачити повну структуру системи та атрибути, що використовуються. Для формування першого універсального відношення T я об’єднала всі атрибути з обраних 5-ти сутностей (Product, DailyPlan, Recipe, Meal та Recommendation) (див рис) в одне відношення T (див. рис. 2.3). Первинним ключем цього універсального відношення я визначила складену комбінацію recommendation_id, recipe_id та product_id, оскільки тільки ця комбінація ідентифікує кожен запис
  

Рисунок 3.3 – Універсальне відношення T 


Першу нормальну форму я перевірила за правилом про атомарність значень на перетині рядка і стовпця. Тобто всі атрибути можна вважати атомарними: часові позначки, числові показники, назви і текстові поля не містять повторюваних списків, тобто відношення T перебуває у 1НФ.
Далі я визначила функціональні залежності в межах T (див рис 2.4), виходячи з логіки предметної області. Отже були виявлені наступні функціональні залежності:
* За product_id я однозначно визначаю властивості продукту, такі як назва, калорійність на 100 грам, склад поживних речовин, одиниця виміру та обмеження.
* За recipe_id я однозначно визначаю дані рецепта: назву, опис, інструкції, калорійність і макроси порції.
* За mealInstance_id я отримую інформацію про конкретний прийом їжі: звʼязок з шаблоном, порядок, орієнтовний час, цільові значення калорій і макросів та привʼязку до daily_plan. 
* За daily_diet_plan_id я визначаю властивості плану дня, включно з користувачем, числом прийомів і датою.
* За recommendation_id я отримую метадані рекомендації: дату створення, тип, статус і загальні параметри, які стосуються запропонованого раціону. 
Відповідно, кожен з цих атрибутів функціонально визначає набір пов’язаних полів у об’єднаному відношенні, а комбінація recommendation_id, recipe_id і product_id визначає повний набір значень для рядка таблиці.
  

Рисунок 3.4 – Функціональні залежності для універсального відношення T 
Друга нормальна форма вимагає, щоб кожен неключовий атрибут повністю залежав від усього первинного ключа. Виявилось, що в моєму відношені багато атрибутів мають часткові залежності. Через наявність таких часткових залежностей універсальне відношення T не можна відразу привести до 2НФ. Тому наступним кроком я планую декомпозувати T у набір відношень, які відповідають природнім сутностям: Product, Recipe,  Recommendation, при цьому зберігаючи звʼязки через зовнішні ключі. Такий розподіл усуне часткові залежності і дозволить привести схему до 2НФ з подальшим приведенням до 3НФ. Тож виділяю наступні універсальні відношення (T2, T3, T4) див. рис. 2.5-2.7
  

Рисунок 3.5 - Універсальне відношення T2
  

Рисунок 3.6 - Універсальне відношення T3
  

Рисунок 2.7 - Універсальне відношення T3


Далі я визначила функціональні залежності для T2, T3, T4 (див. рис. 2.8 - 2.10), виходячи з логіки предметної області. Отже були виявлені наступні функціональні залежності:
  

Рисунок 3.8 –  Функціональні залежності для універсального відношення T2
  

Рисунок 3.9 –  Функціональні залежності для універсального відношення T3
  

Рисунок 3.10 –  Функціональні залежності для універсального відношення T4
Відношення знаходиться у другій нормальній формі (2NF) в тому та тільки в тому випадку, коли воно знаходиться у 1NF, та кожен неключовий атрибут повністю функціонально залежить від первинного ключа відношення.
        Отже, для універсальних відношень T2, T3, T4 мають існувати такі первинні ключі, від яких повністю функціонально залежать неключові атрибути. З рисунків 2.8-2.10, можна зробити висновок, що такими первинними ключами для T2 є recommendation_id, для T3 recipe_id, а для T4 product_id
Як висновок, можна сказати, що відношення T2, T3, T4 знаходяться у 2NF, оскільки вони знаходиться у 1NF та кожен неключовий атрибут повністю функціонально залежить від первинних ключів
Відношення знаходиться в третій нормальній формі (3НФ) в тому та тільки в тому випадку, якщо воно знаходиться у 2НФ та між неключовими атрибутами не має транзитивних залежностей. Кожен неключовий атрибут повинен повністю залежати тільки від первинного ключа. Якщо виявляється транзитивна залежність, ці атрибути відокремлюються в окремі відношення.
        На рисунку 2.8 маємо наявні транзитивні залежності. Отже, першим кроком буде доречно відокремити атрибути, які функціонально залежать від «recommendation_id», тому винесемо їх у відношення Т5 (див.рис.2.11). 
  

Рис 3.11 –  Відношення Т5, утворене в результаті ліквідації транзитивних залежностей
Отже відношення буде містити всю інформацію про рекомендації з первинним ключем «recommendation_id».
Після цього відокремимо всі атрибути, які функціонально залежать від  «daily_plan_id» і винесемо у відношення T6 (див.рис.2.12). 
  

Рис 3.12 –  Відношення Т6, утворене в результаті ліквідації транзитивних залежностей
Таке відношення буде містити інформацію про денний план дієти з первинним ключем «daily_plan_id». 
Відношення T7 (див. рис.2.13) виникне в результаті розділення універсального відношення T2 на відношення з рекомендаціями(T5) таденним планом дієти(T6)
  

Рис 3.13 –  Відношення Т7, утворене в результаті ліквідації транзитивних залежностей
Отже, після розбиття на відношення(T2, T3, T4, T5, T6, T7) була досягнута основна мета, а саме - позбуття транзитивних залежностей. Всі отримані таблиці знаходяться в 3НФ. 
  

Рисунок 3.14 –  Нормалізована частина схеми бази даних 
Схема бази даних, отримана шляхом нормалізації універсального відношення, містить в собі сім  відношень. В деяких відношеннях присутні первинні ключі, які відносяться до інших відношень, у схемі даних вони будуть відігравати роль зовнішніх ключів.
Отже, після виконання нормалізації універсального відношення T отримано схему бази даних, яка відповідає першим трьом нормальним формам. Це дозволяє уникнути надмірність даних, запобігти аномаліям вставки, оновлення та видалення інформації, а також забезпечити цілісність і логічну узгодженість даних. Кожне відношення в схемі було перевірено на наявність функціональних залежностей і приведено до відповідності нормам нормалізації. Завдяки цьому оптимізовано структуру бази даних, що сприяє ефективному використанню пам'яті та підвищенню швидкості виконання запитів. 
3.6 Створення UML діаграми прецедентів для серверної частини системи
Під час проектування серверної частини системи дієтичного менеджменту була розроблена UML-діаграма прецедентів, яка відображає ключові взаємодії користувачів різних ролей із функціональними модулями платформи (див. рис. 2.15).
  

Рисунок 3.15  – UML діаграма 
У системі визначено три типи користувачів: звичайний Користувач, Адміністратор і Суперадміністратор. Кожна з ролей має свій набір завдань та обмежень, що відображено у відповідних прецедентах 
Користувач (User)
Роль звичайного користувача зосереджена навколо персональних рекомендацій і взаємодії з власним профілем. Користувач отримує доступ до сформованих системою рекомендацій, може переглядати їхню деталізацію, фільтрувати та адаптувати під власні потреби (див. рис. 2.16)
  

Рисунок 3.16  – UML діаграма. Користувач
Крім роботи з рекомендаціями, користувач має доступ до основної інформації про власний раціон, показники, історію та базові системні дані. 
Адміністратор (Admin)
Адміністратор – це роль, яка відповідає за наповнення й підтримку даних, на основі яких працює система дієтичних рекомендацій (див. рис. 2.17). 
  

Рисунок 3.17  – UML діаграма. Адміністратор
Одним із ключових блоків діаграми є керування продуктами та рецептами. У межах цього прецедента адміністратор може додавати нові харчові продукти, редагувати їхні властивості, коригувати харчову цінність або характеристики. Це дозволяє вимикати окремі продукти без їх повного видалення, зберігаючи історичну коректність рекомендаційних моделей. Аналогічно влаштований модуль керування рецептами. Адміністратор створює рецепти, редагує їхню структуру, оновлює перелік інгредієнтів. Деактивація рецепта також є додатковим варіантом сценарію, що надає гнучкість у роботі з контентом. Також частиною діаграми є керування дієтичними шаблонами. Система використовує шаблонізацію як основу для генерації добових раціонів та окремих прийомів їжі, тому адміністратор має змогу створювати та редагувати шаблони різного рівня: добові комплекси, шаблони конкретних прийомів їжі та шаблони, засновані на рецептах. Крім контент-частини, адміністратор взаємодіє з модулем рекомендацій. Він може переглядати рекомендації, створені системою для користувачів, застосовувати фільтри для уточнення даних та видаляти нерелевантні рекомендації. 
Суперадміністратор (SuperAdmin)
Суперадміністратор є найвищою роллю в системі, що поєднує адміністративно-технічні та управлінські функції (див. рис. 2.18).
  

Рисунок 3.18  – UML діаграма. СуперАдміністратор
Одним із ключових блоків його відповідальності є керування користувачами. Суперадміністратор може блокувати та розблоковувати облікові записи, редагувати профільні дані за запитами, контролювати активність користувачів і втручатися у випадках порушення використання системи. 
Ще одним важливим модулем є керування ролями. Суперадміністратор може створювати нові ролі, видаляти непотрібні, призначати або позбавляти адміністративних повноважень.
Функціонал супер-адміністратора охоплює також керування системними налаштуваннями. Він може змінювати параметри роботи сервера, впливати на алгоритми автоматичної генерації раціонів та застосовувати технічні шаблони в контекстах, пов’язаних із внутрішньою логікою системи. 
Крім того, супер-адміністратор має повний доступ до системної аналітики. Цей модуль надає узагальнені звіти про стан системи, поведінку користувачів, динаміку рекомендацій та стан контенту. 
3.7 Розробити функції роботи з БД (ORM або CoRM тощо)
3.7.1 Обраний підхід до доступу до БД
        Для доступу до бази даних я обрала ORM Entity Framework Core. Взаємодія з даними реалізована через DbContext та DbSet. Конфігурація таблиць, колонок і звʼязків виконується за допомогою Fluent API. SQL запити вручну не формуються. Усі операції з даними виконуються через класи та методи EF Core на серверній стороні. У додатку В (В.1)  наведено приклад коду класу ApplicationDbContext, який демонструє налаштування DbSet та конфігурацію сутностей за допомогою Fluent API.
3.7.2 Відповідність сутностей і таблиць бази даних
        Я реалізувала відповідність між сутностями предметної області та таблицями бази даних. Кожна сутність відповідає окремій таблиці у БД. У системі визначені такі основні сутності: User, UserProfile, TemplateDietPlan, DailyDietPlan, Meal, Recipe, Product, Recommendation, Device, TelemetrySample, SleepRecord, TrainingSession.Ось приклад однієї з таких таблиць


public class DailyDietPlan
{
    public int DailyDietPlanId { get; set; }
    public int UserId { get; set; }
    public int? TemplateDietPlanId { get; set; }
    public string DailyDietPlanName { get; set; } = string.Empty;
    public string? DailyPlanDescription { get; set; }
    public decimal DailyPlanCalories { get; set; }
    public decimal DailyPlanFat { get; set; }
    public decimal DailyPlanCarbs { get; set; }
    public decimal DailyPlanProtein { get; set; }
    public int DailyPlanNumberOfMeals { get; set; }
    public DailyPlanStatus DailyPlanStatus { get; set; }
    public DateTime DailyPlanCreatedAt { get; set; }


    public User User { get; set; } = null!;
    public TemplateDietPlan? TemplateDietPlan { get; set; }
    public ICollection<Meal> Meals { get; set; } = new List<Meal>();
}
        
Для звʼязків типу багато до багатьох я реалізувала окремі таблиці звʼязку MealRecipe та RecipeProduct. Приклад однієї з таких таблиць:


public class RecipeProduct
{
    public int RecipeId { get; set; }
    public int ProductId { get; set; }
    public decimal QuantityGrams { get; set; }


    public Recipe Recipe { get; set; } = null!;
    public Product Product { get; set; } = null!;
}
3.7.3 Налаштування первинних і зовнішніх ключів
У всіх сутностях первинні ключі налаштовані з параметром ValueGeneratedOnAdd, що забезпечує автоматичне генерування значень.
Я реалізувала такі типи звʼязків між сутностями:
* Один до одного. UserProfile повʼязаний з User через зовнішній ключ UserId.
* Один до багатьох. DailyDietPlan повʼязаний з User, Meal повʼязаний з DailyDietPlan.
* Багато до багатьох. MealRecipe має складений ключ з полів MealId та RecipeId. RecipeProduct має складений ключ з полів RecipeId та ProductId.
* Також я налаштувала додаткові зовнішні ключі. Recommendation повʼязана з Meal через MealInstanceId з поведінкою OnDelete SetNull. Device повʼязаний з User з поведінкою OnDelete Cascade. TelemetrySample, SleepRecord та TrainingSession повʼязані з Device з поведінкою OnDelete Cascade.
3.7.4 Налаштування сутностей через Fluent API
 У ApplicationDbContext я виконала конфігурацію кожної сутності. Для первинних ключів задано імена колонок та автогенерацію значень. Для рядкових полів визначено обмеження довжини та обовʼязковість. Для числових показників застосовано тип decimal з відповідною точністю. Для переліків я реалізувала конверсію enum у тип int. Аналогічні налаштування виконані для всіх сутностей системи. Приклад однієї сутності та її конфігурації:
        modelBuilder.Entity<DailyDietPlan>(entity =>
        {
            entity.ToTable("DailyDietPlans");
            entity.HasKey(e => e.DailyDietPlanId);
            entity.Property(e => e.DailyDietPlanId).HasColumnName("daily_diet_plan_id").ValueGeneratedOnAdd();
            entity.Property(e => e.UserId).HasColumnName("user_id");
            entity.Property(e => e.TemplateDietPlanId).HasColumnName("template_diet_plan_id");
            entity.Property(e => e.DailyDietPlanName).HasColumnName("daily_diet_plan_name").IsRequired().HasMaxLength(200);
            entity.Property(e => e.DailyPlanDescription).HasColumnName("daily_plan_description");
            entity.Property(e => e.DailyPlanCalories).HasColumnName("daily_plan_calories").HasColumnType("decimal(10,2)");
            entity.Property(e => e.DailyPlanFat).HasColumnName("daily_plan_fat").HasColumnType("decimal(10,2)");
            entity.Property(e => e.DailyPlanCarbs).HasColumnName("daily_plan_carbs").HasColumnType("decimal(10,2)");
            entity.Property(e => e.DailyPlanProtein).HasColumnName("daily_plan_protein").HasColumnType("decimal(10,2)");
            entity.Property(e => e.DailyPlanNumberOfMeals).HasColumnName("daily_plan_number_of_meals");
            entity.Property(e => e.DailyPlanStatus).HasColumnName("daily_plan_status").HasConversion<int>();
            entity.Property(e => e.DailyPlanCreatedAt).HasColumnName("daily_plan_created_at");


            entity.HasOne(e => e.User)
                .WithMany(u => u.DailyDietPlans)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);


            entity.HasOne(e => e.TemplateDietPlan)
                .WithMany(t => t.DailyDietPlans)
                .HasForeignKey(e => e.TemplateDietPlanId)
                .OnDelete(DeleteBehavior.SetNull);
        });
3.7.5 Перевірка роботи функцій
 Я перевірила роботу функцій через Swagger. Створення записів виконується без передачі ідентифікатора, який повертається у відповіді. Отримання даних виконується через GET запити. Оновлення реалізоване через PUT з передачею ідентифікатора у маршруті. Видалення виконується через DELETE. Для звʼязків багато до багатьох у запитах передаються всі ключові поля.
3.8 Розробити API (REST або GraphQL, gRPC тощо) для взаємодії серверної частини з клієнтами.
Для взаємодії серверної частини програмної системи з клієнтськими застосунками я спроєктувала REST API на основі протоколу HTTP. Усі запити надсилаються клієнтом до серверної частини за допомогою стандартних HTTP методів, а відповіді повертаються у межах того самого протоколу. 
1. Користувачі (Users)
Для роботи з користувачами API передбачає ендпоінти для отримання списку користувачів та окремого користувача за ідентифікатором за допомогою методу GET. Створення нового користувача виконується через POST із передачею даних у тілі запиту. Оновлення інформації про користувача здійснюється методом PUT з параметром id у маршруті. Видалення користувача реалізовано через DELETE із передачею ідентифікатора користувача в URL.
2. Профілі користувачів (UserProfiles)
Ендпоінти профілів користувачів дозволяють отримати профіль за userId через GET-запит. Створення профілю здійснюється методом POST із привʼязкою до конкретного користувача. Для оновлення параметрів профілю використовується PUT із передачею ідентифікатора профілю. Видалення профілю виконується через DELETE із відповідним id у маршруті.
3. Шаблони дієт (TemplateDietPlans)
API шаблонів дієт підтримує отримання всіх шаблонів або одного шаблону за id через GET. Створення нового шаблону дієти реалізовано методом POST із передачею параметрів дієти у тілі запиту. Оновлення шаблону здійснюється через PUT, а його видалення  через DELETE із використанням ідентифікатора шаблону.
4. Денний дієтичний план (DailyDietPlans)
Для денних дієтичних планів передбачено GET-запити для отримання планів за userId та датою. Створення нового денного плану виконується через POST із передачею ідентифікатора користувача та дати. Зміни у плані вносяться методом PUT за id плану, а видалення здійснюється через DELETE з передачею відповідного ідентифікатора.
5. Прийоми їжі (Meals)
Ендпоінти прийомів їжі дозволяють отримати всі прийоми для конкретного денного плану через GET із параметром dailyDietPlanId. Додавання нового прийому їжі виконується методом POST. Оновлення даних прийому їжі здійснюється через PUT із параметром id, а видалення  через DELETE.
6. Рецепти (Recipes)
API рецептів надає можливість отримувати список рецептів або один рецепт за ідентифікатором через GET. Створення рецепта реалізовано методом POST. Оновлення рецепта виконується через PUT з передачею id у маршруті. Видалення рецепта здійснюється методом DELETE.
7. Продукти (Products)
Для продуктів API передбачає отримання списку або окремого продукту через GET із параметром id. Створення нового продукту здійснюється методом POST. Оновлення інформації про продукт виконується через PUT, а видалення  через DELETE із передачею ідентифікатора продукту.
8. Рекомендації (Recommendations)
Для роботи з рекомендаціями API надає GET-ендпоінти для отримання списку рекомендацій або окремої рекомендації за ідентифікатором. Отримання може виконуватися з фільтрацією за mealId або userId через параметри запиту. Створення нової рекомендації реалізовано методом POST із передачею типу рекомендації та повʼязаного прийому їжі. Оновлення статусу або тексту рекомендації виконується через PUT із параметром id, а видалення через DELETE.
9. Пристрої (Devices)
Ендпоінти пристроїв дозволяють отримати список пристроїв конкретного користувача через GET із параметром userId, а також отримати пристрій за його id. Додавання нового пристрою виконується методом POST із передачею ідентифікатора користувача та типу пристрою. Оновлення параметрів пристрою здійснюється через PUT із параметром id, видалення  через DELETE.
10. Телеметричні дані (TelemetrySamples)
Для телеметричних даних API підтримує GET-запити з параметрами deviceId та діапазоном дат для отримання показників. Створення нового телеметричного запису виконується через POST із передачею ідентифікатора пристрою, типу показника та значення. Оновлення телеметричних даних виконується через PUT за id запису, а видалення через DELETE.
11. Записи сну (SleepRecords)
API записів сну дозволяє отримувати дані сну за deviceId або userId через GET-запити з параметрами фільтрації за датою. Додавання нового запису сну реалізовано методом POST із передачею тривалості та показників якості сну. Оновлення запису здійснюється через PUT із параметром id, а видалення  через DELETE.
12. Тренування (TrainingSessions)
Для тренувальних сесій передбачено GET-ендпоінти для отримання списку тренувань користувача або одного тренування за id. Запити можуть містити параметри userId або date. Створення нового тренування виконується через POST із передачею типу тренування та інтенсивності. Оновлення тренування реалізовано методом PUT, видалення  через DELETE.
13. MealRecipes
Для звʼязку прийомів їжі з рецептами API використовує GET-запити з параметрами mealId або recipeId для отримання відповідних звʼязків. Додавання рецепта до прийому їжі виконується методом POST із передачею mealId та recipeId у тілі запиту. Видалення звʼязку реалізовано через DELETE із використанням обох ідентифікаторів як параметрів.
14. RecipeProducts
Ендпоінти RecipeProducts дозволяють отримувати склад рецепта через GET із параметром recipeId. Додавання продукту до рецепта виконується методом POST із передачею recipeId, productId та кількості. Оновлення кількості продукту здійснюється через PUT із комбінованими параметрами ключів, а видалення звʼязку  через DELETE з передачею recipeId і productId.
3.9 Специфікація API для системи персоналізованих дієт і тренувань
API побудовано на REST-підході з використанням стандартних HTTP-методів. Усі запити і відповіді передаються у форматі JSON. Сервер повністю ізолює модель бази даних від клієнта через DTO (CreateDto, UpdateDto, ResponseDto). Кожна сутність має свій унікальний маршрут, і доступ до конкретних записів здійснюється через їхні ідентифікатори.
1. Users
Створення нового користувача – POST /api/users
Цей ендпоінт дозволяє створити нового користувача в системі. Він очікує на об’єкт UserCreateDto, де обов’язковими є email, пароль, локалізація і роль користувача.
Тіло запиту (UserCreateDto):
* email (string, обов’язкове) – електронна пошта користувача. Повинна бути унікальною і валідною.
* passwordHash (string, обов’язкове) –  хеш пароля.
* locale (string, обов’язкове) – локалізація користувача, наприклад "uk-UA".
* role (string, обов’язкове) – роль користувача ("Admin" або "User").
Тіло відповіді (UserResponseDto):
* userId (int) – унікальний ідентифікатор користувача.
* email (string) – електронна пошта.
* locale (string) –  локалізація.
* role (string) – роль користувача.
* createdAt (datetime) – дата та час створення запису.
Статуси відповіді:
* 201 Created – користувач успішно створений.
* 400 Bad Request – помилка валідації, наприклад, дублювання email або некоректний формат.
Отримання всіх користувачів – GET /api/users
Цей ендпоінт повертає список всіх користувачів у системі. Якщо користувачів немає, повертається статус 204.
Тіло відповіді: список об’єктів UserResponseDto.
Статуси відповіді:
* 200 OK –  список користувачів повернуто.
* 204 No Content – якщо користувачів немає.
Отримання користувача за ID – GET /api/users/{id}
Повертає одного користувача за унікальним ідентифікатором.
Параметри:
* id (int, обов’язкове) – унікальний ідентифікатор користувача.
Тіло відповіді: UserResponseDto
Статуси відповіді:
* 200 OK – користувач знайдений.
* 404 Not Found – користувача з таким ID не існує.
Оновлення користувача – PUT /api/users/{id}
Дозволяє оновлювати дані користувача. Підтримуються необов’язкові поля, щоб можна було змінити лише частину інформації.
Тіло запиту (UserUpdateDto):
* userId (int, обов’язкове) – ID користувача.
* email? (string) – нова електронна пошта.
* passwordHash? (string) – новий хеш пароля.
* locale? (string) – нова локалізація.
* role? (string) – нова роль.
Тіло відповіді: UserResponseDto
Статуси відповіді:
* 200 OK – користувач успішно оновлений.
* 400 Bad Request –  помилка валідації.
* 404 Not Found –  користувач з таким ID не знайдений.
Видалення користувача – DELETE /api/users/{id}
Цей ендпоінт видаляє користувача з системи.
Параметри:
* id (int, обов’язкове) – ID користувача.
Статуси відповіді:
* 204 No Content – користувач успішно видалений.
* 404 Not Found – користувач не знайдений.
2. UserProfiles
UserProfiles зберігає детальну інформацію про користувача: ім’я, зріст, вагу, рівень активності, медичні умови тощо.
Створення профілю користувача – POST /api/userprofiles
Об’єкт UserProfileCreateDto дозволяє створити профіль для конкретного користувача.
Тіло запиту:
* userId (int, обов’язкове) – ID користувача.
* firstName (string, обов’язкове) – ім’я.
* lastName (string, обов’язкове) – прізвище.
* sex (string, обов’язкове) – стать ("male", "female").
* heightCm (float, обов’язкове) – зріст у см.
* currentWeightKg (float, обов’язкове) – вага у кг.
* activityLevel (string, обов’язкове) – рівень активності ("low", "medium", "high").
* medicalConditions? (string, необов’язкове) – медичні умови, якщо є.
* preferredUnits (string, обов’язкове) – одиниці вимірювання ("metric", "imperial").
* birthDate? (datetime, необов’язкове) – дата народження.
Тіло відповіді: UserProfileResponseDto
Статуси відповіді:
* 201 Created – профіль створено.
* 400 Bad Request –  помилка валідації.
Отримання всіх профілів – GET /api/userprofiles
Повертає список всіх профілів користувачів.
Тіло відповіді: список UserProfileResponseDto
Статуси:
* 200 OK – профілі знайдено.
* 204 No Content – профілів немає.
Отримання профілю за ID – GET /api/userprofiles/{id}
Повертає конкретний профіль користувача.
Параметри:
* id (int) – унікальний ID профілю.
Тіло відповіді: UserProfileResponseDto
Статуси:
* 200 OK – профіль знайдено.
* 404 Not Found – профіль не знайдено.
Оновлення профілю – PUT /api/userprofiles/{id}
Дозволяє змінювати інформацію профілю.
Тіло запиту (UserProfileUpdateDto):
* profileId (int, обов’язкове) – ID профілю.
* Можна змінювати будь-які поля необов’язково: firstName, lastName, sex, heightCm, currentWeightKg, activityLevel, medicalConditions, preferredUnits, birthDate.
Тіло відповіді: UserProfileResponseDto
Статуси:
* 200 OK – успішно оновлено.
* 400 Bad Request – помилка валідації.
* 404 Not Found – профіль не знайдено.
Видалення профілю – DELETE /api/userprofiles/{id}
Видаляє профіль користувача з системи.
Статуси:
* 204 No Content – профіль видалено.
* 404 Not Found – профіль не знайдено.
3. TemplateDietPlans
Створення шаблону дієти – POST /api/templatedietplans
Ендпоінт створює шаблон дієтичного плану, який можна потім використовувати для генерації денних планів.
Тіло запиту (TemplateDietPlanCreateDto):
* templateName (string, обов’язкове) –  назва шаблону.
* templateDescription? (string, необов’язкове) – опис шаблону.
* templateCaloriesMin / templateCaloriesMax (int, обов’язкове) – мінімальна та максимальна калорійність.
* templateProteinMin / templateProteinMax (float, обов’язкове) – мінімальний та максимальний вміст білків.
* templateFatMin / templateFatMax (float, обов’язкове) – мінімальний та максимальний вміст жирів.
* templateCarbsMin / templateCarbsMax (float, обов’язкове) – мінімальний та максимальний вміст вуглеводів.
* templateNumberOfMeals (int, обов’язкове) – кількість прийомів їжі на день.
* templateStatus (string, обов’язкове) – статус шаблону ("Active", "Inactive").
* templateCreatedAt? (datetime, необов’язкове) – дата створення, автоматично генерується сервером, якщо не задано.
Тіло відповіді (TemplateDietPlanResponseDto):
* templateDietPlanId (int) – унікальний ID шаблону.
* Всі інші поля відповідають створеному шаблону.
Статуси:
* 201 Created – шаблон створено успішно.

* 400 Bad Request – помилка валідації, наприклад, невірні значення калорій або білків.
Отримання всіх шаблонів – GET /api/templatedietplans
Повертає список усіх шаблонів, наявних у системі.
Тіло відповіді: список TemplateDietPlanResponseDto
Статуси:
   * 200 OK – знайдені шаблони.
   * 204 No Content – шаблонів немає.
Отримання шаблону за ID – GET /api/templatedietplans/{id}
Повертає конкретний шаблон за унікальним ідентифікатором.
Статуси:
   * 200 OK – шаблон знайдено.
   * 404 Not Found – шаблон не знайдено.
Оновлення шаблону –PUT /api/templatedietplans/{id}
Дозволяє змінити будь-які характеристики шаблону.
Тіло запиту (TemplateDietPlanUpdateDto):
   * templateDietPlanId (int, обов’язкове) – ID шаблону.
   * Можливе оновлення всіх полів, крім ID, які можна передавати необов’язково.
Статуси:
   * 200 OK – успішно оновлено.
   * 400 Bad Request – помилка валідації.
   * 404 Not Found – шаблон не знайдено.
Видалення шаблону – DELETE /api/templatedietplans/{id}
Видаляє шаблон із системи.
Статуси:
   * 204 No Content – шаблон видалено.
   * 404 Not Found – шаблон не знайдено.
4. DailyDietPlans
Створення денного плану – POST /api/dailydietplans
Дозволяє створити індивідуальний денний дієтичний план на основі шаблону або вручну.
Тіло запиту (DailyDietPlanCreateDto):
   * userId (int, обов’язкове) – ID користувача.
   * templateDietPlanId? (int, необов’язкове) – шаблон, якщо план базується на ньому.
   * dailyDietPlanName (string, обов’язкове) – назва плану.
   * dailyPlanDescription? (string) – опис.
   * dailyPlanCalories, dailyPlanFat, dailyPlanCarbs, dailyPlanProtein (float, обов’язкове) – цільові макроелементи.
   * dailyPlanNumberOfMeals (int, обов’язкове) – кількість прийомів їжі.
   * dailyPlanStatus (string, обов’язкове) – статус ("Active", "Planned").
Тіло відповіді (DailyDietPlanResponseDto):
        Усі зазначені поля, плюс dailyDietPlanId.
Статуси:
   * 201 Created – успішно створено.
   * 400 Bad Request – помилка валідації.
Отримання всіх денних планів – GET /api/dailydietplans
Повертає список усіх денних планів користувачів.
Статуси:
   * 200 OK – знайдені плани.
   * 204 No Content – планів немає.
Отримання плану за ID – GET /api/dailydietplans/{id}
Повертає один денний план.
Статуси:
   * 200 OK – план знайдено.
   * 404 Not Found – план не знайдено.
Оновлення плану –PUT /api/dailydietplans/{id}
Дозволяє змінювати будь-які поля денного плану.
Тіло запиту (DailyDietPlanUpdateDto):
         Можна оновлювати всі поля окрім ID, які передаються необов’язково.
Статуси:
   * 200 OK – успішно оновлено.
   * 400 Bad Request – помилка валідації.
   * 404 Not Found – план не знайдено.
Видалення плану – DELETE /api/dailydietplans/{id}
Видаляє денний план.
Статуси:
   * 204 No Content – успішно видалено.
   * 404 Not Found – план не знайдено.
5. Meals
Створення прийому їжі – POST /api/meals
Ендпоінт дозволяє створювати прийоми їжі в рамках денного дієтичного плану. Кожен прийом їжі має визначений порядок і цільові макроелементи.
Тіло запиту (MealCreateDto):
   * dailyDietPlanId (int, обов’язкове) – ID денного плану, до якого належить прийом.
   * mealTime (datetime, обов’язкове) – час прийому їжі.
   * mealOrder (int, обов’язкове) – порядковий номер прийому (наприклад, 1 – сніданок, 2 – обід).
   * mealTargetCalories (float, обов’язкове) – цільові калорії для прийому.
   * mealTargetFat / mealTargetCarbs / mealTargetProtein (float, обов’язкове) – цільові макроелементи.
Тіло відповіді (MealResponseDto):
   * mealId (int) – унікальний ID прийому.
   * Всі інші поля відповідають введеним значенням.
Статуси:
   * 201 Created – прийом успішно створено.
   * 400 Bad Request – помилка валідації, наприклад, відсутні обов’язкові поля або некоректний час.
Отримання всіх прийомів – GET /api/meals
Повертає список усіх прийомів їжі, зареєстрованих у системі.
Статуси:
   * 200 OK – знайдені прийоми.
   * 204 No Content – прийомів немає.
Отримання прийому за ID – GET /api/meals/{id}
Повертає конкретний прийом їжі за його унікальним ідентифікатором.
Статуси:
   * 200 OK – прийом знайдено.
   * 404 Not Found – прийом не існує.
Оновлення прийому – PUT /api/meals/{id}
Дозволяє змінювати будь-які характеристики прийому, включно з порядком, часом та цільовими макроелементами.
Тіло запиту (MealUpdateDto):
   * mealId (int, обов’язкове) – ID прийому.
   * dailyDietPlanId?, mealTime?, mealOrder?, mealTargetCalories?, mealTargetFat?, mealTargetCarbs?, mealTargetProtein? — необов’язкові поля для оновлення.
Статуси:
   * 200 OK – успішно оновлено.
   * 400 Bad Request – помилка валідації.
   * 404 Not Found – прийом не знайдено.
Видалення прийому – DELETE /api/meals/{id}
Видаляє прийом із системи.
Статуси:
   * 204 No Content – прийом успішно видалено.
   * 404 Not Found – прийом не знайдено.
6. Recipes
Створення рецепта – POST /api/recipes
Дозволяє додавати рецепти, які потім можуть включатися у прийоми їжі.
Тіло запиту (RecipeCreateDto):
   * recipeName (string, обов’язкове) – назва рецепта.
   * recipeInstructions (string, обов’язкове) – інструкція приготування.
   * recipeCaloriesPerPortion, recipeFatPerPortion, recipeCarbsPerPortion, recipeProteinPerPortion (float, обов’язкове) – макроелементи на порцію.
   * recipeProductsGrams (list of {productId:int, grams:float}) – перелік продуктів із кількістю грамів.
Тіло відповіді (RecipeResponseDto):
   * recipeId (int) – унікальний ID рецепта.
   * Інші поля повторюють введені дані.
Статуси:
   * 201 Created – рецепт створено.
   * 400 Bad Request – помилка валідації.
Отримання всіх рецептів – GET /api/recipes
Повертає всі рецепти системи.
Статуси:
   * 200 OK – знайдено рецепти.
   * 204 No Content – рецептів немає.
Отримання рецепта за ID – GET /api/recipes/{id}
Повертає конкретний рецепт.
Статуси:
   * 200 OK – рецепт знайдено.
   * 404 Not Found – рецепт не існує.
Оновлення рецепта – PUT /api/recipes/{id}
Дозволяє змінювати інструкції, макроелементи та склад продуктів.
Тіло запиту (RecipeUpdateDto):
   * recipeId (int, обов’язкове) – ID рецепта.
   * Можливе оновлення будь-яких полів необов’язково.
Статуси:
   * 200 OK – успішно оновлено.
   * 400 Bad Request – помилка валідації
   * 404 Not Found – рецепт не знайдено.
Видалення рецепта – DELETE /api/recipes/{id}
Видаляє рецепт із системи.
Статуси:
   * 204 No Content – успішно видалено.
   * 404 Not Found – рецепт не знайдено.
7. Products
Створення продукту – POST /api/products
Ендпоінт дозволяє додавати продукти, які можна включати до рецептів.
Тіло запиту (ProductCreateDto):
   * productName (string, обов’язкове) – назва продукту.
   * caloriesPer100g, proteinPer100g, fatPer100g, carbsPer100g (float, обов’язкове) – макроелементи на 100 грамів.
   * restriction?, allergens?, unit? (string, необов’язкове) – додаткові характеристики.
Тіло відповіді (ProductResponseDto):
   * productId (int) – унікальний ID продукту.
   * Інші поля повторюють запит.
Статуси:
   * 201 Created – продукт створено.
   * 400 Bad Request – помилка валідації.
Отримання всіх продуктів – GET /api/products
Повертає список всіх продуктів.
Статуси:
   * 200 OK – продукти знайдено.
   * 204 No Content – продуктів немає.
Отримання продукту за ID – GET /api/products/{id}
Повертає конкретний продукт.
Статуси:
   * 200 OK – продукт знайдено.
   * 404 Not Found – продукт не існує.
Оновлення продукту – PUT /api/products/{id}
Дозволяє змінювати характеристики продукту.
Тіло запиту (ProductUpdateDto):
   * productId (int, обов’язкове).
   * Можливе оновлення всіх полів необов’язково.
Статуси:
   * 200 OK – успішно оновлено.
   * 400 Bad Request – помилка валідації.
   * 404 Not Found – продукт не знайдено.
Видалення продукту – DELETE /api/products/{id}
Видаляє продукт із системи.
Статуси:
   * 204 No Content – продукт успішно видалено.
   * 404 Not Found – продукт не знайдено.
8. Recommendations
Створення рекомендації – POST /api/recommendations
Цей ендпоінт дозволяє створювати рекомендації для прийомів їжі або користувачів. Рекомендації можуть бути різного типу: харчові, активність, поради щодо сну тощо.
Тіло запиту (RecommendationCreateDto):
   * mealInstanceId? (int, необов’язкове) – ID прийому їжі, до якого відноситься рекомендація.
   * recommendationType (string, обов’язкове) – тип рекомендації (наприклад, «харчування», «тренування»).
   * recommendationPayload? (string, необов’язкове) – додатковий текст або структура даних рекомендації.
   * recommendationStatus (string, обов’язкове) – статус рекомендації (активна, виконана, застаріла)
Тіло відповіді (RecommendationResponseDto):
   * recommendationId (int) – унікальний ID рекомендації.
   * Всі інші поля повторюють введені дані.
Статуси:
   * 201 Created – рекомендація успішно створена.
   * 400 Bad Request – помилка валідації, відсутні обов’язкові поля або некоректні значення.
Отримання всіх рекомендацій – GET /api/recommendations
Повертає список усіх рекомендацій в системі.
Статуси:
   * 200 OK — рекомендації знайдено.
   * 204 No Content — рекомендацій немає.
Отримання рекомендації за ID — GET /api/recommendations/{id}
Повертає конкретну рекомендацію за її ID.
Статуси:
   * 200 OK – рекомендація знайдена.
   * 404 Not Found – рекомендація не існує.
Оновлення рекомендації – PUT /api/recommendations/{id}
Дозволяє змінювати тип, статус або payload рекомендації.
Тіло запиту (RecommendationUpdateDto):
   * recommendationId (int, обов’язкове) – ID рекомендації.
   * mealInstanceId?, recommendationType?, recommendationPayload?, recommendationStatus? – необов’язкові поля для оновлення.
Статуси:
   * 200 OK – успішно оновлено.
   * 400 Bad Request – помилка валідації.
   * 404 Not Found – рекомендація не знайдена.
Видалення рекомендації – DELETE /api/recommendations/{id}
Видаляє рекомендацію з системи.
Статуси:
   * 204 No Content – рекомендація успішно видалена.
   * 404 Not Found – рекомендація не знайдена.
9. Devices
Реєстрація пристрою – POST /api/devices
Дозволяє реєструвати пристрої користувачів, наприклад фітнес-трекери або смарт-годинники.
Тіло запиту (DeviceCreateDto):
   * userId (int, обов’язкове) – користувач, до якого належить пристрій.
   * deviceType (string, обов’язкове) - тип пристрою (наприклад, «smartwatch», «band»).
   * connectionType (string, обов’язкове) – тип підключення (Bluetooth, Wi-Fi).
   * lastSeen? (datetime, необов’язкове) – остання дата активності.
   * serial (string, обов’язкове) – серійний номер пристрою.
Тіло відповіді (DeviceResponseDto):
   * deviceId (int) – унікальний ID пристрою.
   * Інші поля повторюють введені значення.
Статуси:
   * 201 Created – пристрій успішно зареєстровано.
   * 400 Bad Request – помилка валідації.
Отримання всіх пристроїв – GET /api/devices
Повертає список усіх зареєстрованих пристроїв.
Статуси:
   * 200 OK – пристрої знайдено.
   * 204 No Content – пристроїв немає.
Отримання пристрою за ID – GET /api/devices/{id}
Повертає конкретний пристрій за ID.
Статуси:
   * 200 OK – пристрій знайдено.
   * 404 Not Found – пристрій не існує.
Оновлення пристрою – PUT /api/devices/{id}
Дозволяє змінювати тип, статус або останню активність пристрою.
Тіло запиту (DeviceUpdateDto):
   * deviceId (int, обов’язкове).
   * userId?, deviceType?, connectionType?, lastSeen?, serial? — необов’язкові поля.
Статуси:
   * 200 OK – успішно оновлено.
   * 400 Bad Request – помилка валідації.
   * 404 Not Found – пристрій не знайдено.
Видалення пристрою – DELETE /api/devices/{id}
Видаляє пристрій із системи.
Статуси:
   * 204 No Content – пристрій успішно видалено.
   * 404 Not Found – пристрій не знайдено.
10. TelemetrySamples
Додавання телеметричної вибірки – POST /api/telemetrysamples
Телеметричні дані дозволяють відстежувати показники пристроїв (серцевий ритм, активність тощо).
Тіло запиту (TelemetrySampleCreateDto):
   * deviceId (int, обов’язкове) – пристрій, який передає дані.
   * timestamp (datetime, обов’язкове) – час запису вибірки.
   * telemetryType (string, обов’язкове) – тип даних (наприклад, «heartRate»).
   * telemetryValue (float, обов’язкове) – значення показника.
Тіло відповіді (TelemetrySampleResponseDto):
   * sampleId (int) – унікальний ID вибірки.
   * Повторює усі вхідні дані.
Статуси:
   * 201 Created – вибірка успішно додана.
   * 400 Bad Request – помилка валідації.
Отримання всіх вибірок – GET /api/telemetrysamples
Повертає список всіх телеметричних вибірок.
Статуси:
   * 200 OK – вибірки знайдено.
   * 204 No Content – вибірок немає.
Отримання вибірки за ID – GET /api/telemetrysamples/{id}
Повертає конкретну телеметричну вибірку.
Статуси:
   * 200 OK – вибірка знайдена.
   * 404 Not Found – вибірка не існує.
Оновлення вибірки – PUT /api/telemetrysamples/{id}
Дозволяє змінювати тип або значення показника.
Тіло запиту (TelemetrySampleUpdateDto):
   * sampleId (int, обов’язкове).
   * deviceId?, timestamp?, telemetryType?, telemetryValue? – необов’язкові.
Статуси:
   * 200 OK – успішно оновлено.
   * 400 Bad Request – помилка валідації.
   * 404 Not Found – вибірка не знайдена.
Видалення вибірки – DELETE /api/telemetrysamples/{id}
Видаляє вибірку.
Статуси:
   * 204 No Content – успішно видалено.
   * 404 Not Found – вибірка не існує.
11. SleepRecords (Записи сну)
Створення запису сну – POST /api/sleeprecords
Дозволяє фіксувати дані про сон користувача, отримані з пристрою.
Тіло запиту (SleepRecordCreateDto):
   * deviceId (int, обов’язкове) – ідентифікатор пристрою.
   * date (date, обов’язкове) – дата сну.
   * totalSleepMinutes (int, обов’язкове) – загальна кількість хвилин сну.
   * deepSleepMinutes (int, обов’язкове) – хвилини глибокого сну.
   * lightSleepMinutes (int, обов’язкове) – хвилини легкого сну.
   * awakeMinutes (int, обов’язкове) – хвилини пробудження.
   * sleepQuality (string, обов’язкове) – якість сну (наприклад, «добра», «середня»).
   * startTime, endTime (datetime, обов’язкове) – час початку та завершення сну.
Тіло відповіді (SleepRecordResponseDto):
   * sleepId (int) – унікальний ідентифікатор запису.
   * Повтор усіх полів запиту для підтвердження.
Статуси:
   * 201 Created — запис успішно створено.
   * 400 Bad Request — некоректні дані або відсутні обов’язкові поля.
Отримання всіх записів сну — GET /api/sleeprecords
Повертає список усіх записів сну.
Статуси:
   * 200 OK – записи знайдено.
   * 204 No Content – записів немає.
Отримання запису сну за ID – GET /api/sleeprecords/{id}
Повертає конкретний запис сну за ідентифікатором.
Статуси:
   * 200 OK – запис знайдено.
   * 404 Not Found – запис не існує.
Оновлення запису сну – PUT /api/sleeprecords/{id}
Дозволяє змінювати дані про сон.
Тіло запиту (SleepRecordUpdateDto):
   * sleepId (int, обов’язкове).
   * deviceId?, date?, totalSleepMinutes?, deepSleepMinutes?, lightSleepMinutes?, awakeMinutes?, sleepQuality?, startTime?, endTime? – необов’язкові поля.
Статуси:
   * 200 OK – успішно оновлено.
   * 400 Bad Request – помилка валідації.
   * 404 Not Found – запис не знайдено.
Видалення запису сну – DELETE /api/sleeprecords/{id}
Видаляє запис сну з системи.
Статуси:
   * 204 No Content — успішно видалено.
   * 404 Not Found — запис не знайдено.
12. TrainingSessions (Тренувальні сесії)
Створення тренування – POST /api/trainingsessions
Дозволяє додавати інформацію про тренування користувача.
Тіло запиту (TrainingSessionCreateDto):
   * deviceId (int, обов’язкове) – пристрій, який фіксував тренування.
   * startTime, endTime (datetime, обов’язкове) – час початку та завершення тренування.
type (string, обов’язкове) – тип тренування (наприклад, «кардіо», «силове»).
   * intensity (string, обов’язкове) – інтенсивність («низька», «середня», «висока»).
   * durationInMin (int, обов’язкове) – тривалість у хвилинах.
   * caloriesEstimated (float, обов’язкове) – оцінка витрачених калорій.
Тіло відповіді (TrainingSessionResponseDto):
      * sessionId (int) – унікальний ідентифікатор тренування.
      * Повтор усіх полів запиту.
Статуси:
      * 201 Created – тренування успішно додано.
      * 400 Bad Request – помилка валідації.
Отримання всіх тренувань – GET /api/trainingsessions
Повертає список усіх тренувальних сесій.
Статуси:
      * 200 OK – тренування знайдено.
      * 204 No Content – записів немає.
Отримання тренування за ID – GET /api/trainingsessions/{id}
Повертає конкретну тренувальну сесію за ідентифікатором.
Статуси:
      * 200 OK – запис знайдено.
      * 404 Not Found – тренування не існує.
Оновлення тренування – PUT /api/trainingsessions/{id}
Дозволяє змінювати інформацію про тренування.
Тіло запиту (TrainingSessionUpdateDto):
      * sessionId (int, обов’язкове).
      * deviceId?, startTime?, endTime?, type?, intensity?, durationInMin?, caloriesEstimated? – необов’язкові поля.
Статуси:
      * 200 OK – успішно оновлено.
      * 400 Bad Request – помилка валідації.
      * 404 Not Found – тренування не знайдено.
Видалення тренування – DELETE /api/trainingsessions/{id}
Видаляє запис про тренування.
Статуси:
      * 204 No Content – успішно видалено.
      * 404 Not Found – запис не знайдено.
13. MealRecipes (Зв’язок прийом їжі  та рецепт)
Створення зв’язку – POST /api/mealrecipes
Створює зв’язок між прийомом їжі та рецептом.
Тіло запиту (MealRecipeCreateDto):
      * mealId (int, обов’язкове).
      * recipeId (int, обов’язкове).
Тіло відповіді (MealRecipeResponseDto):
      * mealId, recipeId – ключові поля.
      * Можна додати дату створення зв’язку.
Статуси:
      * 201 Created — зв’язок створено.
      * 400 Bad Request — помилка валідації.
Отримання всіх зв’язків — GET /api/mealrecipes
Повертає список усіх зв’язків прийом їжі ↔ рецепт.
Статуси:
      * 200 OK – зв’язки знайдено.
      * 204 No Content – записів немає.
Отримання зв’язку за ключем – GET /api/mealrecipes/by-keys?mealId={mealId}&recipeId={recipeId}
Повертає конкретний зв’язок.
Статуси:
      * 200 OK – зв’язок знайдено.
      * 404 Not Found – зв’язок не існує.
Видалення зв’язку – DELETE /api/mealrecipes?mealId={mealId}&recipeId={recipeId}
Видаляє зв’язок за складеним ключем.
Статуси:
      * 204 No Content – успішно видалено.
      * 404 Not Found – зв’язок не знайдено.
14. RecipeProducts (Зв’язок рецепт тп продукт)
Створення зв’язку – POST /api/recipeproducts
Зв’язує рецепт із продуктами та вказує кількість кожного продукту.
Тіло запиту (RecipeProductCreateDto):
      * recipeId (int, обов’язкове).
      * productId (int, обов’язкове).
      * quantityGrams (float, обов’язкове) – кількість продукту в грамах.
Тіло відповіді (RecipeProductResponseDto):
      * recipeId, productId, quantityGrams.
Статуси:
      * 201 Created – зв’язок створено.
      * 400 Bad Request – помилка валідації.
Отримання всіх зв’язків – GET /api/recipeproducts
Повертає список усіх зв’язків рецепт ↔ продукт.
Статуси:
      * 200 OK – зв’язки знайдено.
      * 204 No Content – записів немає.
Отримання зв’язку за ключем – GET /api/recipeproducts/by-keys?recipeId={recipeId}&productId={productId}
Повертає конкретний зв’язок.
Статуси:
      * 200 OK – зв’язок знайдено.
      * 404 Not Found – зв’язок не існує.
Оновлення зв’язку – PUT /api/recipeproducts
Дозволяє змінювати кількість продукту у рецепті.
Статуси:
      * 200 OK – успішно оновлено.
      * 400 Bad Request – помилка валідації.
      * 404 Not Found – зв’язок не знайдено.
Видалення зв’язку – DELETE /api/recipeproducts?recipeId={recipeId}&productId={productId}
Видаляє зв’язок рецепт ↔ продукт.
Статуси:
      * 204 No Content – успішно видалено.
      * 404 Not Found – зв’язок не знайдено.
У межах лабораторної роботи реалізовано серверну частину програмної системи з доступом до бази даних та обробкою запитів через REST API. Серверна частина забезпечує виконання CRUD-операцій для всіх сутностей системи та коректну взаємодію з БД через ORM Entity Framework Core. API приймає HTTP запити від клієнтів, обробляє їх на рівні контролерів і сервісів та повертає структуровані відповіді у форматі JSON. Реалізовані ендпоінти відповідають спроєктованій специфікації та забезпечують стабільну роботу серверної логіки системи.
3.10 Створення програмної реалізації API та функцій роботи з БД:
У межах лабораторної роботи реалізовано серверну частину програмної системи з доступом до бази даних та обробкою запитів через REST API. Серверна частина забезпечує виконання CRUD-операцій для всіх сутностей системи та коректну взаємодію з БД через ORM Entity Framework Core. API приймає HTTP запити від клієнтів, обробляє їх на рівні контролерів і сервісів та повертає структуровані відповіді у форматі JSON. Реалізовані ендпоінти відповідають спроєктованій специфікації та забезпечують стабільну роботу серверної логіки системи.
3.11 Перевірка роботи створеного програмного коду серверної частини системи
Роботу створеного програмного коду серверної частини системи було перевірено шляхом виконання запитів до реалізованих ендпоінтів API. У процесі перевірки підтверджено коректність обробки HTTP-запитів, доступу до бази даних та повернення відповідей у визначеному форматі JSON. Усі основні функції серверної частини працюють відповідно до спроєктованої логіки та вимог.
________________
ВИСНОВКИ
У ході виконання лабораторної роботи було спроєктовано та описано серверну частину програмної системи автоматизованих дієт. Було визначено архітектуру системи, спроєктовано структуру бази даних, описано основні моделі предметної області та зв’язки між ними. Для роботи з базою даних обрано ORM Entity Framework Core, налаштовано контекст даних і конфігурацію сутностей за допомогою Fluent API. Також було спроєктовано REST API для взаємодії серверної частини з клієнтськими застосунками, визначено типи ендпоінтів, HTTP-методи, формати обміну даними та підхід до використання DTO. Окремо створено специфікацію API з описом ендпоінтів і прикладами використання. Реалізовано програмний код серверної частини з доступом до бази даних та обробкою запитів через API, а також перевірено коректність його роботи.
________________
ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/Vo8mS_1tVro
Хронологічний опис відеозапису:
00:00 - Вступна частина. Опис вимог до другої лабораторної частини
00:42 - Розробка будову програмної системи
01:15 - Опис моделей та зв’язків
01:35 - Побудова ER - діаграми
02:41 - Побудова логічної моделі бази даних на базі ER-діаграми
03:21 - Нормалізація. Побудова логічної моделі бази даних шляхом нормалізації
04:19 -  Створення UML діаграми прецедентів для серверної частини системи
05:45 - Розробка функції роботи з БД (ORM - EF)
06:51 - Розробити API (REST) для взаємодії серверної
частини з клієнтами.
07:45 - Специфікація API для системи персоналізованих дієт і тренувань
08:40 - Тестування створеного API для  системи  автоматизованих дієт
12:35 - Дякую за увагу!
________________
ДОДАТОК Б
Програмний код
Б.1 Код класу ApplicationDbContext


  1 using Microsoft.EntityFrameworkCore;
  2 using FitnessProject.Entities;
  3 
  4 namespace FitnessProject.Data;
  5 
  6 public class ApplicationDbContext : DbContext
  7 {
  8     public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
  9         : base(options)
 10     {
 11     }
 12 
 13     public DbSet<User> Users { get; set; }
 14     public DbSet<UserProfile> UserProfiles { get; set; }
 15     public DbSet<TemplateDietPlan> TemplateDietPlans { get; set; }
 16     public DbSet<DailyDietPlan> DailyDietPlans { get; set; }
 17     public DbSet<Meal> Meals { get; set; }
 18     public DbSet<Recipe> Recipes { get; set; }
 19     public DbSet<Product> Products { get; set; }
 20     public DbSet<MealRecipe> MealRecipes { get; set; }
 21     public DbSet<RecipeProduct> RecipeProducts { get; set; }
 22     public DbSet<Recommendation> Recommendations { get; set; }
 23     public DbSet<Device> Devices { get; set; }
 24     public DbSet<TelemetrySample> TelemetrySamples { get; set; }
 25     public DbSet<SleepRecord> SleepRecords { get; set; }
 26     public DbSet<TrainingSession> TrainingSessions { get; set; }
 27 
 28     protected override void OnModelCreating(ModelBuilder modelBuilder)
 29     {
 30         base.OnModelCreating(modelBuilder);
 31 
 32         modelBuilder.Entity<User>(entity =>
 33         {
 34             entity.ToTable("Users");
 35             entity.HasKey(e => e.UserId);
 36             entity.Property(e => e.UserId).HasColumnName("user_id").ValueGeneratedOnAdd();
 37             entity.Property(e => e.Email).HasColumnName("email").IsRequired().HasMaxLength(255);
 38             entity.Property(e => e.PasswordHash).HasColumnName("password_hash").IsRequired();
 39             entity.Property(e => e.CreatedAt).HasColumnName("created_at");
 40             entity.Property(e => e.Locale).HasColumnName("locale").HasMaxLength(10);
 41             entity.Property(e => e.Role).HasColumnName("role").HasConversion<int>();
 42         });
 43 
 44         modelBuilder.Entity<UserProfile>(entity =>
 45         {
 46             entity.ToTable("UserProfiles");
 47             entity.HasKey(e => e.ProfileId);
 48             entity.Property(e => e.ProfileId).HasColumnName("profile_id").ValueGeneratedOnAdd();
 49             entity.Property(e => e.UserId).HasColumnName("user_id");
 50             entity.Property(e => e.FirstName).HasColumnName("first_name").IsRequired().HasMaxLength(100);
 51             entity.Property(e => e.LastName).HasColumnName("last_name").IsRequired().HasMaxLength(100);
 52             entity.Property(e => e.Sex).HasColumnName("sex").HasConversion<int>();
 53             entity.Property(e => e.HeightCm).HasColumnName("height_cm").HasColumnType("decimal(5,2)");
 54             entity.Property(e => e.CurrentWeightKg).HasColumnName("current_weight_kg").HasColumnType("decimal(5,2)");
 55             entity.Property(e => e.ActivityLevel).HasColumnName("activity_level").HasConversion<int>();
 56             entity.Property(e => e.MedicalConditions).HasColumnName("medical_conditions");
 57             entity.Property(e => e.PreferredUnits).HasColumnName("preferred_units").HasConversion<int>();
 58             entity.Property(e => e.BirthDate).HasColumnName("birth_date");
 59 
 60             entity.HasOne(e => e.User)
 61                 .WithOne(u => u.UserProfile)
 62                 .HasForeignKey<UserProfile>(e => e.UserId)
 63                 .OnDelete(DeleteBehavior.Cascade);
 64         });
 65 
 66         modelBuilder.Entity<TemplateDietPlan>(entity =>
 67         {
 68             entity.ToTable("TemplateDietPlans");
 69             entity.HasKey(e => e.TemplateDietPlanId);
 70             entity.Property(e => e.TemplateDietPlanId).HasColumnName("template_diet_plan_id").ValueGeneratedOnAdd();
 71             entity.Property(e => e.TemplateName).HasColumnName("template_name").IsRequired().HasMaxLength(200);
 72             entity.Property(e => e.TemplateDescription).HasColumnName("template_description");
 73             entity.Property(e => e.TemplateCaloriesMin).HasColumnName("template_calories_min").HasColumnType("decimal(10,2)");
 74             entity.Property(e => e.TemplateCaloriesMax).HasColumnName("template_calories_max").HasColumnType("decimal(10,2)");
 75             entity.Property(e => e.TemplateProteinMin).HasColumnName("template_protein_min").HasColumnType("decimal(10,2)");
 76             entity.Property(e => e.TemplateProteinMax).HasColumnName("template_protein_max").HasColumnType("decimal(10,2)");
 77             entity.Property(e => e.TemplateFatMin).HasColumnName("template_fat_min").HasColumnType("decimal(10,2)");
 78             entity.Property(e => e.TemplateFatMax).HasColumnName("template_fat_max").HasColumnType("decimal(10,2)");
 79             entity.Property(e => e.TemplateCarbsMin).HasColumnName("template_carbs_min").HasColumnType("decimal(10,2)");
 80             entity.Property(e => e.TemplateCarbsMax).HasColumnName("template_carbs_max").HasColumnType("decimal(10,2)");
 81             entity.Property(e => e.TemplateNumberOfMeals).HasColumnName("template_number_of_meals");
 82             entity.Property(e => e.TemplateStatus).HasColumnName("template_status").HasConversion<int>();
 83             entity.Property(e => e.TemplateCreatedAt).HasColumnName("template_created_at");
 84         });
 85 
 86         modelBuilder.Entity<DailyDietPlan>(entity =>
 87         {
 88             entity.ToTable("DailyDietPlans");
 89             entity.HasKey(e => e.DailyDietPlanId);
 90             entity.Property(e => e.DailyDietPlanId).HasColumnName("daily_diet_plan_id").ValueGeneratedOnAdd();
 91             entity.Property(e => e.UserId).HasColumnName("user_id");
 92             entity.Property(e => e.TemplateDietPlanId).HasColumnName("template_diet_plan_id");
 93             entity.Property(e => e.DailyDietPlanName).HasColumnName("daily_diet_plan_name").IsRequired().HasMaxLength(200);
 94             entity.Property(e => e.DailyPlanDescription).HasColumnName("daily_plan_description");
 95             entity.Property(e => e.DailyPlanCalories).HasColumnName("daily_plan_calories").HasColumnType("decimal(10,2)");
 96             entity.Property(e => e.DailyPlanFat).HasColumnName("daily_plan_fat").HasColumnType("decimal(10,2)");
 97             entity.Property(e => e.DailyPlanCarbs).HasColumnName("daily_plan_carbs").HasColumnType("decimal(10,2)");
 98             entity.Property(e => e.DailyPlanProtein).HasColumnName("daily_plan_protein").HasColumnType("decimal(10,2)");
 99             entity.Property(e => e.DailyPlanNumberOfMeals).HasColumnName("daily_plan_number_of_meals");
100             entity.Property(e => e.DailyPlanStatus).HasColumnName("daily_plan_status").HasConversion<int>();
101             entity.Property(e => e.DailyPlanCreatedAt).HasColumnName("daily_plan_created_at");
102 
103             entity.HasOne(e => e.User)
104                 .WithMany(u => u.DailyDietPlans)
105                 .HasForeignKey(e => e.UserId)
106                 .OnDelete(DeleteBehavior.Cascade);
107 
108             entity.HasOne(e => e.TemplateDietPlan)
109                 .WithMany(t => t.DailyDietPlans)
110                 .HasForeignKey(e => e.TemplateDietPlanId)
111                 .OnDelete(DeleteBehavior.SetNull);
112         });
113 
114         modelBuilder.Entity<Meal>(entity =>
115         {
116             entity.ToTable("Meals");
117             entity.HasKey(e => e.MealId);
118             entity.Property(e => e.MealId).HasColumnName("meal_id").ValueGeneratedOnAdd();
119             entity.Property(e => e.DailyDietPlanId).HasColumnName("daily_diet_plan_id");
120             entity.Property(e => e.MealTime).HasColumnName("meal_time").HasConversion<int>();
121             entity.Property(e => e.MealOrder).HasColumnName("meal_order");
122             entity.Property(e => e.MealTargetCalories).HasColumnName("meal_target_calories").HasColumnType("decimal(10,2)");
123             entity.Property(e => e.MealTargetFat).HasColumnName("meal_target_fat").HasColumnType("decimal(10,2)");
124             entity.Property(e => e.MealTargetCarbs).HasColumnName("meal_target_carbs").HasColumnType("decimal(10,2)");
125             entity.Property(e => e.MealTargetProtein).HasColumnName("meal_target_protein").HasColumnType("decimal(10,2)");
126 
127             entity.HasOne(e => e.DailyDietPlan)
128                 .WithMany(d => d.Meals)
129                 .HasForeignKey(e => e.DailyDietPlanId)
130                 .OnDelete(DeleteBehavior.Cascade);
131         });
132 
133         modelBuilder.Entity<Recipe>(entity =>
134         {
135             entity.ToTable("Recipes");
136             entity.HasKey(e => e.RecipeId);
137             entity.Property(e => e.RecipeId).HasColumnName("recipe_id").ValueGeneratedOnAdd();
138             entity.Property(e => e.RecipeName).HasColumnName("recipe_name").IsRequired().HasMaxLength(200);
139             entity.Property(e => e.RecipeInstructions).HasColumnName("recipe_instructions").IsRequired();
140             entity.Property(e => e.RecipeCaloriesPerPortion).HasColumnName("recipe_calories_per_portion").HasColumnType("decimal(10,2)");
141             entity.Property(e => e.RecipeFatPerPortion).HasColumnName("recipe_fat_per_portion").HasColumnType("decimal(10,2)");
142             entity.Property(e => e.RecipeCarbsPerPortion).HasColumnName("recipe_carbs_per_portion").HasColumnType("decimal(10,2)");
143             entity.Property(e => e.RecipeProteinPerPortion).HasColumnName("recipe_protein_per_portion").HasColumnType("decimal(10,2)");
144             entity.Property(e => e.RecipeProductsGrams).HasColumnName("recipe_products_grams").HasColumnType("decimal(10,2)");
145         });
146 
147         modelBuilder.Entity<Product>(entity =>
148         {
149             entity.ToTable("Products");
150             entity.HasKey(e => e.ProductId);
151             entity.Property(e => e.ProductId).HasColumnName("product_id").ValueGeneratedOnAdd();
152             entity.Property(e => e.ProductName).HasColumnName("product_name").IsRequired().HasMaxLength(200);
153             entity.Property(e => e.CaloriesPer100g).HasColumnName("calories_per_100g").HasColumnType("decimal(10,2)");
154             entity.Property(e => e.ProteinPer100g).HasColumnName("protein_per_100g").HasColumnType("decimal(10,2)");
155             entity.Property(e => e.FatPer100g).HasColumnName("fat_per_100g").HasColumnType("decimal(10,2)");
156             entity.Property(e => e.CarbsPer100g).HasColumnName("carbs_per_100g").HasColumnType("decimal(10,2)");
157             entity.Property(e => e.Restriction).HasColumnName("restriction");
158             entity.Property(e => e.Allergens).HasColumnName("allergens");
159             entity.Property(e => e.Unit).HasColumnName("unit").HasMaxLength(50);
160         });
161 
162         modelBuilder.Entity<MealRecipe>(entity =>
163         {
164             entity.ToTable("MealRecipes");
165             entity.HasKey(e => new { e.MealId, e.RecipeId });
166             entity.Property(e => e.MealId).HasColumnName("meal_id");
167             entity.Property(e => e.RecipeId).HasColumnName("recipe_id");
168 
169             entity.HasOne(e => e.Meal)
170                 .WithMany(m => m.MealRecipes)
171                 .HasForeignKey(e => e.MealId)
172                 .OnDelete(DeleteBehavior.Cascade);
173 
174             entity.HasOne(e => e.Recipe)
175                 .WithMany(r => r.MealRecipes)
176                 .HasForeignKey(e => e.RecipeId)
177                 .OnDelete(DeleteBehavior.Cascade);
178         });
179 
180         modelBuilder.Entity<RecipeProduct>(entity =>
181         {
182             entity.ToTable("RecipeProducts");
183             entity.HasKey(e => new { e.RecipeId, e.ProductId });
184             entity.Property(e => e.RecipeId).HasColumnName("recipe_id");
185             entity.Property(e => e.ProductId).HasColumnName("product_id");
186             entity.Property(e => e.QuantityGrams).HasColumnName("quantity_grams").HasColumnType("decimal(10,2)");
187 
188             entity.HasOne(e => e.Recipe)
189                 .WithMany(r => r.RecipeProducts)
190                 .HasForeignKey(e => e.RecipeId)
191                 .OnDelete(DeleteBehavior.Cascade);
192 
193             entity.HasOne(e => e.Product)
194                 .WithMany(p => p.RecipeProducts)
195                 .HasForeignKey(e => e.ProductId)
196                 .OnDelete(DeleteBehavior.Cascade);
197         });
198 
199         modelBuilder.Entity<Recommendation>(entity =>
200         {
201             entity.ToTable("Recommendations");
202             entity.HasKey(e => e.RecommendationId);
203             entity.Property(e => e.RecommendationId).HasColumnName("recommendation_id").ValueGeneratedOnAdd();
204             entity.Property(e => e.MealInstanceId).HasColumnName("meal_instance_id");
205             entity.Property(e => e.RecommendationCreatedAt).HasColumnName("recommendation_created_at");
206             entity.Property(e => e.RecommendationType).HasColumnName("recommendation_type").HasConversion<int>();
207             entity.Property(e => e.RecommendationPayload).HasColumnName("recommendation_payload");
208             entity.Property(e => e.RecommendationStatus).HasColumnName("recommendation_status").HasConversion<int>();
209 
210             entity.HasOne(e => e.Meal)
211                 .WithMany(m => m.Recommendations)
212                 .HasForeignKey(e => e.MealInstanceId)
213                 .OnDelete(DeleteBehavior.SetNull);
214         });
215 
216         modelBuilder.Entity<Device>(entity =>
217         {
218             entity.ToTable("Devices");
219             entity.HasKey(e => e.DeviceId);
220             entity.Property(e => e.DeviceId).HasColumnName("device_id").ValueGeneratedOnAdd();
221             entity.Property(e => e.UserId).HasColumnName("user_id");
222             entity.Property(e => e.DeviceType).HasColumnName("device_type").HasConversion<int>();
223             entity.Property(e => e.ConnectionType).HasColumnName("connection_type").HasConversion<int>();
224             entity.Property(e => e.LastSeen).HasColumnName("last_seen");
225             entity.Property(e => e.Serial).HasColumnName("serial").HasMaxLength(100);
226 
227             entity.HasOne(e => e.User)
228                 .WithMany(u => u.Devices)
229                 .HasForeignKey(e => e.UserId)
230                 .OnDelete(DeleteBehavior.Cascade);
231         });
232 
233         modelBuilder.Entity<TelemetrySample>(entity =>
234         {
235             entity.ToTable("TelemetrySamples");
236             entity.HasKey(e => e.SampleId);
237             entity.Property(e => e.SampleId).HasColumnName("sample_id").ValueGeneratedOnAdd();
238             entity.Property(e => e.DeviceId).HasColumnName("device_id");
239             entity.Property(e => e.Timestamp).HasColumnName("timestamp");
240             entity.Property(e => e.TelemetryType).HasColumnName("telemetry_type").HasConversion<int>();
241             entity.Property(e => e.TelemetryValue).HasColumnName("telemetry_value").HasColumnType("decimal(10,2)");
242 
243             entity.HasOne(e => e.Device)
244                 .WithMany(d => d.TelemetrySamples)
245                 .HasForeignKey(e => e.DeviceId)
246                 .OnDelete(DeleteBehavior.Cascade);
247         });
248 
249         modelBuilder.Entity<SleepRecord>(entity =>
250         {
251             entity.ToTable("SleepRecords");
252             entity.HasKey(e => e.SleepId);
253             entity.Property(e => e.SleepId).HasColumnName("sleep_id").ValueGeneratedOnAdd();
254             entity.Property(e => e.DeviceId).HasColumnName("device_id");
255             entity.Property(e => e.Date).HasColumnName("date");
256             entity.Property(e => e.TotalSleepMinutes).HasColumnName("total_sleep_minutes");
257             entity.Property(e => e.DeepSleepMinutes).HasColumnName("deep_sleep_minutes");
258             entity.Property(e => e.LightSleepMinutes).HasColumnName("light_sleep_minutes");
259             entity.Property(e => e.AwakeMinutes).HasColumnName("awake_minutes");
260             entity.Property(e => e.SleepQuality).HasColumnName("sleep_quality").HasColumnType("decimal(5,2)");
261             entity.Property(e => e.StartTime).HasColumnName("start_time");
262             entity.Property(e => e.EndTime).HasColumnName("end_time");
263 
264             entity.HasOne(e => e.Device)
265                 .WithMany(d => d.SleepRecords)
266                 .HasForeignKey(e => e.DeviceId)
267                 .OnDelete(DeleteBehavior.Cascade);
268         });
269 
270         modelBuilder.Entity<TrainingSession>(entity =>
271         {
272             entity.ToTable("TrainingSessions");
273             entity.HasKey(e => e.SessionId);
274             entity.Property(e => e.SessionId).HasColumnName("session_id").ValueGeneratedOnAdd();
275             entity.Property(e => e.DeviceId).HasColumnName("device_id");
276             entity.Property(e => e.StartTime).HasColumnName("start_time");
277             entity.Property(e => e.EndTime).HasColumnName("end_time");
278             entity.Property(e => e.Type).HasColumnName("type").HasConversion<int>();
279             entity.Property(e => e.Intensity).HasColumnName("intensity").HasConversion<int>();
280             entity.Property(e => e.DurationInMin).HasColumnName("duration_in_min");
281             entity.Property(e => e.CaloriesEstimated).HasColumnName("calories_estimated").HasColumnType("decimal(10,2)");
282 
283             entity.HasOne(e => e.Device)
284                 .WithMany(d => d.TrainingSessions)
285                 .HasForeignKey(e => e.DeviceId)
286                 .OnDelete(DeleteBehavior.Cascade);
287         });
288     }
289 }