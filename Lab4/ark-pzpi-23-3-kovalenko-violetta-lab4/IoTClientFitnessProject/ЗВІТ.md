# Звіт про виконання лабораторної роботи №4
## «Створення IoT клієнта»

### Вступ

У ході виконання лабораторної роботи було розроблено IoT клієнт для системи фітнес-трекінгу, який симулює роботу Apple Watch та взаємодіє з серверною частиною через HTTP API. Реалізовано всі необхідні компоненти: архітектуру, UML діаграми, бізнес-логіку, налаштування та програмну реалізацію.

---

## 1. Розробка будови програмного забезпечення IoT клієнта

### 1.1. Проектування архітектури

Архітектура IoT клієнта спроектована з урахуванням модульності та розділення відповідальності. Система складається з наступних основних компонентів:

**Структура проекту:**
```
IoTClientFitnessProject/
├── config/                    # Конфігураційні файли
│   ├── config.default.json   # Дефолтні налаштування
│   └── config.json           # Користувацькі налаштування
├── src/                       # Вихідний код
│   ├── base_api_client.py    # Базовий клас для HTTP запитів
│   ├── telemetry_api_client.py    # Клієнт для телеметрії
│   ├── diet_api_client.py         # Клієнт для планів дієти
│   ├── statistics_api_client.py   # Клієнт для статистики
│   ├── user_api_client.py         # Клієнт для профілів
│   ├── recommendations_api_client.py  # Клієнт для рекомендацій
│   ├── api_client.py              # Головний об'єднуючий клієнт
│   ├── config_manager.py          # Управління конфігурацією
│   ├── sensor_simulator.py         # Симулятор датчиків
│   ├── statistics_calculator.py    # Локальна статистика
│   ├── watch_gui.py                # Графічний інтерфейс
│   └── main.py                     # Точка входу
├── diagrams/                  # UML діаграми
│   ├── use_case_diagram.puml
│   └── activity_diagram.puml
└── requirements.txt           # Залежності Python
```

**Модулі обробки даних:**
- **SensorSimulator** — генерує симульовані дані з датчиків (пульс, кроки, сон)
- **StatisticsCalculator** — виконує локальну агрегацію та обчислення статистики
- **ConfigManager** — управляє конфігурацією системи (завантаження, збереження, валідація)

**Модулі мережевих протоколів:**
- **BaseApiClient** — базовий клас з реалізацією HTTP запитів з повторними спробами
- **TelemetryApiClient** — відправка телеметрії на сервер
- **DietApiClient** — завантаження планів дієти та рецептів
- **StatisticsApiClient** — завантаження статистики
- **UserApiClient** — робота з профілями користувачів
- **RecommendationsApiClient** — завантаження рекомендацій

**Модуль управління пристроями:**
- **ConfigManager** — конфігурування параметрів пристрою (device_id, user_id, інтервали датчиків)
- **WatchGUI** — графічний інтерфейс для управління симуляцією та перегляду даних

### 1.2. Взаємодія з серверною частиною

Клієнт взаємодіє з сервером через RESTful API на основі HTTP протоколу:
- **Відправка даних:** POST запити до `/api/telemetry/receive` та `/api/SleepRecords`
- **Отримання даних:** GET запити до `/api/dailydietplans`, `/api/statistics`, `/api/userprofiles`, `/api/recommendations`
- **Обробка помилок:** автоматичні повторні спроби при мережевих помилках, обробка HTTP помилок

---

## 2. Створення UML діаграми прецедентів

UML діаграма прецедентів описує основні сценарії взаємодії користувача та системи з IoT клієнтом. Діаграма визначає функціональність системи з точки зору користувача та показує, як різні актори взаємодіють з системою для виконання конкретних завдань.

### 2.1. Актори системи

Діаграма містить три основні актори:

1. **Користувач (User)** — основний актор, який взаємодіє з IoT клієнтом через графічний інтерфейс. Користувач ініціює операції налаштування системи, управління симуляцією датчиків, перегляд даних на головному екрані та отримання плану дієти.

2. **Client API** — актор, який представляє клієнтську частину API та відповідає за відправку телеметрії на сервер, генерацію статистики, генерацію планів дієти та рекомендацій. Цей актор ініціює операції, пов'язані з обробкою та передачею даних між клієнтом та сервером.

3. **Server SensorSimulator** — актор, який представляє серверну частину системи симуляції датчиків. Відповідає за генерацію сирих даних з датчиків (кроки, пульс, сон), які потім обробляються системою.

### 2.2. Пакети та прецеденти

Функціональність системи організована в логічні групи (пакети), кожен з яких відповідає за певний аспект роботи IoT клієнта:

#### 2.2.1. Пакет "Ініціалізація та налаштування" (актор: Користувач)

Цей пакет містить прецеденти, пов'язані з початковою конфігурацією та налаштуванням IoT клієнта:

- **Запустити IoT клієнта (Launch IoT Client)** — основний прецедент ініціалізації системи. Користувач запускає додаток, після чого система автоматично завантажує конфігурацію та ініціалізує всі компоненти (ConfigManager, ApiClient, SensorSimulator, StatisticsCalculator, WatchGUI). Прецедент обов'язково включає "Налаштування параметрів".

- **Налаштування параметрів (Configure Parameters)** — конфігурування параметрів IoT клієнта:
  - URL сервера API
  - ID пристрою (device_id)
  - ID користувача (user_id)
  - Інтервали зчитування датчиків (heart_rate_interval, steps_interval)
  - Параметри повторних спроб (retry_attempts, retry_delay)
  - Таймаути HTTP запитів

- **Скинути конфігурацію (Reset Configuration)** — відновлення всіх параметрів до дефолтних значень, збережених у `config.default.json`. Користувач може використати цей прецедент для швидкого повернення до початкових налаштувань.

**Сценарій взаємодії:** Користувач запускає IoT клієнт → система завантажує конфігурацію → користувач може змінити параметри або скинути їх до дефолтів.

#### 2.2.2. Пакет "Робота з датчиками" (актор: Server SensorSimulator)

Пакет описує прецеденти генерації сирих даних з датчиків на серверній стороні:

- **Згенерувати дані про кроки (Generate Step Data)** — генерація інкрементальних значень кроків (1-7 кроків за раз) через `SensorSimulator.read_steps()`. Використовується для симуляції роботи датчика кроків.

- **Згенерувати дані про пульс (Generate Pulse Data)** — генерація випадкового значення пульсу в діапазоні 60-100 bpm через `SensorSimulator.read_heart_rate()`. Використовується для симуляції роботи датчика пульсу.

- **Згенерувати дані про сон (Generate Sleep Data)** — генерація структурованих даних про сон (загальний час 6-9 годин, глибокий/легкий сон, якість 70-95%) через `SensorSimulator.generate_sleep_data()`. Використовується для симуляції роботи датчика сну.

**Сценарій взаємодії:** Server SensorSimulator генерує сирі дані з датчиків → дані передаються в систему для подальшої обробки та відправки на сервер.

#### 2.2.3. Пакет "Робота з телеметрією" (актор: Client API)

Пакет описує прецеденти відправки телеметрії на сервер:

- **Відправити дані про кроки (Send Step Data)** — надсилання кроків на сервер через HTTP POST запит до `/api/telemetry/receive` з `telemetryType=1`. Прецедент може бути розширений обробкою помилок мережі та API запитів.

- **Відправити дані про сон (Send Sleep Data)** — надсилання даних про сон на сервер через HTTP POST запит до `/api/SleepRecords`. Прецедент може бути розширений обробкою помилок.

- **Відправити дані про пульс (Send Pulse Data)** — надсилання виміряного пульсу на сервер через HTTP POST запит до `/api/telemetry/receive` з `telemetryType=0`. Прецедент може бути розширений обробкою помилок.

**Сценарій взаємодії:** Client API отримує дані з датчиків → формує HTTP POST запит → відправляє дані на сервер → при помилці виконується обробка помилок.

#### 2.2.4. Пакет "Симуляція датчиків" (актор: Користувач)

Пакет описує автоматичну симуляцію роботи датчиків:

- **Запустити симуляцію кроків (Start Step Simulation)** — запуск автоматичної симуляції, яка генерує та відправляє кроки кожні 5 секунд (або інший інтервал з конфігурації). Симуляція працює в окремому потоці, не блокуєчи графічний інтерфейс.

- **Зупинити симуляцію кроків (Stop Step Simulation)** — зупинка автоматичної симуляції кроків. Користувач може зупинити симуляцію в будь-який момент.

**Сценарій взаємодії:** Користувач запускає симуляцію → система автоматично генерує та відправляє кроки кожні 5 секунд → користувач може зупинити симуляцію.

#### 2.2.5. Пакет "Головний екран" (актор: Користувач)

Пакет описує прецеденти перегляду поточних даних на головному екрані:

- **Оновити дані (Refresh Data)** — оновлення всіх показників на головному екрані (пульс, кроки, бал активності). Прецедент обов'язково включає "Переглянути поточну кількість кроків" та "Переглянути останній замір пульсу". Система завантажує останні дані з сервера через API запит до `/api/statistics`.

- **Переглянути поточну кількість кроків (View Current Step Count)** — відображення загальної кількості кроків за день, отриманої з сервера або розрахованої локально.

- **Переглянути останній замір пульсу (View Last Pulse Measurement)** — відображення останнього виміряного значення пульсу, отриманого з сервера або з локальної статистики.

**Сценарій взаємодії:** Користувач натискає кнопку "Оновити дані" → система завантажує статистику з сервера → відображаються поточні показники (кроки, пульс).

#### 2.2.6. Пакет "Отримання плана дієти" (актор: Користувач)

Пакет описує прецеденти отримання та перегляду плану дієти:

- **Завантажити план дієти (Load Diet Plan)** — отримання плану дієти з сервера через HTTP GET запит до `/api/dailydietplans`. Система фільтрує плани за `user_id` та сортує за датою, вибираючи найновіший план. Прецедент обов'язково включає "Переглянути денний раціон", "Переглянути прийоми їжі" та "Переглянути добову норму КБЖУ". Прецедент може бути розширений обробкою помилок.

- **Переглянути денний раціон (View Daily Ration)** — відображення загального денного раціону з калорійністю та макронутрієнтами.

- **Переглянути прийоми їжі (View Meals)** — відображення прийомів їжі з плану дієти (сніданок, обід, вечеря, перекуси) з їхніми часами та калорійністю.

- **Переглянути добову норму КБЖУ (View Daily Calorie/Protein/Fat/Carb Norm)** — відображення добової норми калорій, білків, жирів та вуглеводів, розрахованої на основі профілю користувача.

**Сценарій взаємодії:** Користувач натискає "Завантажити план дієти" → система отримує план з сервера → відображаються денний раціон, прийоми їжі та норма КБЖУ.

#### 2.2.7. Пакет "Генерація плана дієти" (актор: Client API)

Пакет описує прецеденти генерації плану дієти на сервері:

- **Генерація дієтичного плану (Generate Diet Plan)** — центральний прецедент генерації плану дієти на сервері. Client API ініціює запит на генерацію плану, після чого сервер виконує розрахунки та створює план. Прецедент включає "Згенерувати денний раціон", "Згенерувати прийоми їжі" та "Згенерувати добову норму КБЖУ".

- **Згенерувати денний раціон (Generate Daily Ration)** — генерація денного раціону на основі профілю користувача, його активності та медичних обмежень. Прецедент обов'язково включає "Генерація дієтичного плану".

- **Згенерувати прийоми їжі (Generate Meals)** — генерація прийомів їжі (сніданок, обід, вечеря, перекуси) з відповідними рецептами та порціями. Прецедент обов'язково включає "Генерація дієтичного плану".

- **Згенерувати добову норму КБЖУ (Generate Daily Calorie/Protein/Fat/Carb Norm)** — розрахунок добової норми калорій, білків, жирів та вуглеводів на основі профілю користувача (вік, стать, зріст, вага, рівень активності). Прецедент обов'язково включає "Генерація дієтичного плану" та "Фільтрація продуктових/медичних обмежень".

- **Фільтрація продуктових/медичних обмежень (Filter Product/Medical Restrictions)** — фільтрація продуктів та рецептів на основі медичних обмежень користувача (алергені, діабет, вегетаріанство тощо). Прецедент обов'язково включає "Згенерувати добову норму КБЖУ" та має підпрецеденти:
  - **Фільтрація за алергенами (Filter by Allergens)** — виключення продуктів, що містять алергени користувача
  - **Фільтрація за продуктовими обмеженнями (Filter by Product Restrictions)** — виключення продуктів, що не відповідають дієтичним обмеженням (наприклад, м'ясо для вегетаріанців)
  - **Фільтрація за медичними обмеженнями (Filter by Medical Restrictions)** — виключення продуктів, що не відповідають медичним показанням (наприклад, цукор для діабетиків)

**Сценарій взаємодії:** Client API ініціює генерацію плану дієти → сервер фільтрує продукти за обмеженнями → генерує денний раціон, прийоми їжі та норму КБЖУ → план зберігається на сервері та стає доступним для завантаження.

#### 2.2.8. Пакет "Генерація рекомендацій" (актор: Client API)

Пакет описує прецеденти генерації рекомендацій на сервері:

- **Генерація рекомендацій (Generate Recommendations)** — центральний прецедент генерації рекомендацій на сервері. Client API ініціює запит на генерацію рекомендацій, після чого сервер аналізує дані користувача та створює персоналізовані рекомендації. Прецедент включає "Коригування прийомів їжі" та "Коригування денного КБЖУ".

- **Коригування прийомів їжі (Adjust Meals)** — коригування прийомів їжі на основі аналізу харчових звичок та активності користувача. Прецедент обов'язково включає "Генерація рекомендацій".

- **Коригування денного КБЖУ (Adjust Daily Calorie/Protein/Fat/Carb Norm)** — коригування добової норми калорій та макронутрієнтів на основі досягнення цілей користувача та його активності. Прецедент обов'язково включає "Генерація рекомендацій".

**Сценарій взаємодії:** Client API ініціює генерацію рекомендацій → сервер аналізує дані користувача → генерує рекомендації щодо коригування прийомів їжі та норми КБЖУ → рекомендації зберігаються на сервері.

#### 2.2.9. Пакет "Генерація статистики" (актор: Client API)

Пакет описує прецеденти генерації статистики на сервері:

- **Генерація статистики (Generate Statistics)** — центральний прецедент генерації статистики на сервері. Client API ініціює запит на генерацію статистики, після чого сервер агрегує телеметрію та обчислює статистичні показники. Прецедент може бути розширений "Генерація денної статистики" та "Генерація тижневої статистики".

- **Генерація денної статистики (Generate Daily Statistics)** — генерація агрегованої статистики за поточний день (середній/мінімальний/максимальний пульс, загальна кількість кроків, статистика сну, бал активності). Прецедент опціонально розширює "Генерація статистики".

- **Генерація тижневої статистики (Generate Weekly Statistics)** — генерація статистики за останній тиждень з трендами зміни показників (тренди пульсу, кроків, сну, активності). Прецедент опціонально розширює "Генерація статистики".

**Сценарій взаємодії:** Client API ініціює генерацію статистики → сервер агрегує телеметрію за день/тиждень → обчислює статистичні показники та тренди → статистика зберігається на сервері та стає доступною для завантаження.

### 2.3. Типи зв'язків між прецедентами

Діаграма використовує три типи зв'язків:

1. **Асоціація** (суцільна стрілка) — зв'язок між актором та прецедентом, що показує, хто ініціює виконання прецеденту. Наприклад:
   - Користувач ініціює "Запустити IoT клієнта", "Запустити симуляцію кроків", "Оновити дані", "Завантажити план дієти"
   - Client API ініціює "Відправити дані про кроки", "Генерація статистики", "Генерація дієтичного плану", "Генерація рекомендацій"
   - Server SensorSimulator ініціює "Згенерувати дані про кроки", "Згенерувати дані про пульс", "Згенерувати дані про сон"

2. **Включення (include)** — обов'язковий зв'язок, що показує, що один прецедент завжди включає поведінку іншого. Наприклад:
   - "Запустити IoT клієнта" завжди включає "Налаштування параметрів"
   - "Оновити дані" завжди включає "Переглянути поточну кількість кроків" та "Переглянути останній замір пульсу"
   - "Завантажити план дієти" завжди включає "Переглянути денний раціон", "Переглянути прийоми їжі" та "Переглянути добову норму КБЖУ"
   - "Генерація дієтичного плану" завжди включає "Згенерувати денний раціон", "Згенерувати прийоми їжі" та "Згенерувати добову норму КБЖУ"
   - "Згенерувати добову норму КБЖУ" завжди включає "Фільтрація продуктових/медичних обмежень"

3. **Розширення (extend)** — опціональний зв'язок, що показує, що один прецедент може бути розширений іншим за певних умов. Наприклад:
   - "Генерація статистики" може бути розширена "Генерація денної статистики" або "Генерація тижневої статистики" залежно від типу запиту
   - "Відправити дані про кроки", "Відправити дані про сон", "Відправити дані про пульс" можуть бути розширені обробкою помилок мережі та API запитів
   - "Завантажити план дієти" може бути розширений обробкою помилок при відсутності плану або помилках сервера

### 2.4. Відповідність вимогам

Діаграма прецедентів повністю відповідає вимогам лабораторної роботи:

✅ **Налаштування параметрів клієнта** — реалізовано через пакет "Ініціалізація та налаштування" (актор: Користувач) з прецедентами:
- "Запустити IoT клієнта" — ініціалізація системи
- "Налаштування параметрів" — конфігурування URL сервера, ID пристрою та користувача, інтервалів датчиків
- "Скинути конфігурацію" — відновлення дефолтних налаштувань

✅ **Надсилання даних на сервер** — реалізовано через пакет "Робота з телеметрією" (актор: Client API) з прецедентами:
- "Відправити дані про кроки" — надсилання телеметрії кроків
- "Відправити дані про сон" — надсилання даних про сон
- "Відправити дані про пульс" — надсилання телеметрії пульсу

✅ **Оновлення прошивки/даних** — реалізовано через прецедент "Оновити дані" в пакеті "Головний екран" (актор: Користувач), який завантажує актуальні дані з сервера та відображає поточні показники.

✅ **Основні сценарії взаємодії** — діаграма описує всі основні сценарії:
- **Ініціалізація та налаштування системи** — пакет "Ініціалізація та налаштування"
- **Генерація даних з датчиків** — пакет "Робота з датчиками" (Server SensorSimulator)
- **Надсилання телеметрії на сервер** — пакет "Робота з телеметрією" (Client API)
- **Автоматична симуляція датчиків** — пакет "Симуляція датчиків" (Користувач)
- **Перегляд поточних даних** — пакет "Головний екран" (Користувач)
- **Отримання та перегляд плану дієти** — пакет "Отримання плана дієти" (Користувач)
- **Генерація плану дієти на сервері** — пакет "Генерація плана дієти" (Client API)
- **Генерація рекомендацій на сервері** — пакет "Генерація рекомендацій" (Client API)
- **Генерація статистики на сервері** — пакет "Генерація статистики" (Client API)

Діаграма чітко розділяє відповідальність між клієнтською та серверною частинами системи, показуючи, як різні актори взаємодіють для виконання завдань.

**Файл:** `diagrams/use_case_diagram.puml`

---

## 3. Розробка бізнес-логіки та функцій налаштування IoT клієнта

### 3.1. Бізнес-логіка для роботи з даними пристроїв

**3.1.1. Зчитування даних з датчиків (SensorSimulator):**

- **Генерація пульсу:** метод `read_heart_rate()` генерує випадкове значення в діапазоні 60-100 bpm
- **Генерація кроків:** метод `read_steps()` генерує інкрементальні значення кроків (1-7 кроків за раз)
- **Генерація даних про сон:** метод `generate_sleep_data()` створює реалістичні дані про сон:
  - Загальний час сну: 6-9 годин (360-540 хвилин)
  - Глибокий сон: 15-25% від загального
  - Легкий сон: 50-70% від загального
  - Якість сну: 70-95%

**3.1.2. Відправлення даних на сервер:**

- **Відправка телеметрії:** метод `send_telemetry()` відправляє одиночні значення (пульс, кроки) через POST запит
- **Відправка батчу телеметрії:** метод `send_telemetry_batch()` дозволяє відправити кілька значень одночасно
- **Відправка даних про сон:** метод `send_sleep_record()` відправляє структуровані дані про сон

**3.1.3. Обробка даних:**

- **Локальна статистика:** клас `StatisticsCalculator` виконує агрегацію даних на клієнті:
  - Обчислення середнього, мінімального, максимального пульсу
  - Підрахунок загальної кількості кроків
  - Аналіз якості сну
  - Розрахунок балу активності

### 3.2. Функції налаштування IoT клієнта

**3.2.1. Конфігурування мережі та параметрів підключення (ConfigManager):**

Реалізовано повноцінне управління конфігурацією через JSON файли:

- **Завантаження конфігурації:** метод `load_config()` завантажує налаштування з `config.json`, якщо файл не існує — використовуються дефолтні значення з `config.default.json`
- **Збереження конфігурації:** метод `save_config()` зберігає змінені налаштування
- **Оновлення окремих параметрів:** метод `update_setting()` дозволяє змінити конкретний параметр
- **Скидання до дефолтних значень:** метод `reset_to_defaults()` відновлює початкові налаштування

**Параметри конфігурації:**
- **Сервер:** `base_url`, `timeout`, `retry_attempts`, `retry_delay`
- **Пристрій:** `device_id`, `user_id`
- **Датчики:** `heart_rate_interval`, `steps_interval`, `batch_size`, `send_interval`
- **Логування:** рівень деталізації логів

**3.2.2. Управління енергоспоживанням:**

Хоча це симулятор, реалізовано оптимізацію запитів:
- Використання HTTP сесій для перевикористання з'єднань
- Батчова відправка даних (якщо потрібно)
- Налаштовувані інтервали відправки даних
- Автоматичні повторні спроби з експоненційною затримкою

**3.2.3. Відновлення параметрів за замовчуванням:**

Метод `reset_to_defaults()` дозволяє швидко відновити всі налаштування до початкового стану, що корисно при налагодженні або після помилок конфігурації.

---

## 4. Створення UML діаграми діяльності

Створено діаграму діяльності, яка відображає основні процеси та послідовність дій IoT клієнта.

**Основні процеси, описані в діаграмі:**

1. **Ініціалізація системи:**
   - Завантаження конфігурації
   - Створення компонентів (ConfigManager, ApiClient, SensorSimulator, StatisticsCalculator, WatchGUI)
   - Відображення графічного інтерфейсу

2. **Процес відправки телеметрії:**
   - Генерація даних датчиками
   - Відправка на сервер через HTTP
   - Обробка успішних/неуспішних відповідей
   - Оновлення локальної статистики
   - Відображення результатів в GUI

3. **Процес завантаження даних з сервера:**
   - Запит профілю користувача
   - Запит планів дієти (з сортуванням за датою)
   - Завантаження деталей плану та рецептів
   - Запит рекомендацій
   - Запит статистики (денна/тижнева)
   - Відображення отриманих даних

4. **Процес симуляції датчиків:**
   - Автоматична генерація кроків кожні 5 секунд
   - Відправка на сервер
   - Оновлення логів та відображення

Діаграма також показує обробку помилок та альтернативні шляхи виконання.

**Файл:** `diagrams/activity_diagram.puml`

---

## 5. Програмна реалізація бізнес-логіки та функцій налаштування

У ході виконання лабораторної роботи було реалізовано повноцінну програмну реалізацію бізнес-логіки IoT клієнта, включаючи обробку даних з датчиків, комунікацію з серверною частиною через HTTP протокол та функції налаштування системи.

### 5.1. Реалізація обробки даних з датчиків

**Файл:** `src/sensor_simulator.py`

Клас `SensorSimulator` реалізує симуляцію роботи фізичних датчиків IoT пристрою. Кожен метод генерує реалістичні дані, які імітують роботу реальних датчиків Apple Watch.

#### 5.1.1. Генерація даних про пульс

Метод `read_heart_rate()` реалізує генерацію випадкового значення пульсу в нормальному діапазоні:

```python
def read_heart_rate(self) -> float:
    # Генерація пульсу в нормальному діапазоні (60-100 bpm)
    heart_rate = random.randint(60, 100)
    return float(heart_rate)
```

**Логіка роботи:**
- Генерує випадкове ціле число в діапазоні 60-100 bpm (удари на хвилину)
- Повертає значення як float для сумісності з API
- Діапазон відповідає нормальному пульсу людини в спокої

**Використання:** Викликається при ручному вимірюванні пульсу користувачем через GUI або при генерації батчу телеметрії.

#### 5.1.2. Генерація даних про кроки

Метод `read_steps()` реалізує генерацію інкрементальних значень кроків:

```python
def read_steps(self) -> int:
    # Додаємо випадкову кількість кроків (0-50 за один виклик)
    new_steps = random.randint(0, 50)
    self.steps_count += new_steps
    return self.steps_count
```

**Логіка роботи:**
- Використовує накопичувальний лічильник `self.steps_count`
- При кожному виклику додає випадкову кількість кроків (0-50)
- Повертає накопичене значення
- Можна скинути через метод `reset_steps()`

**Особливості реалізації:** У реальній системі симуляції кроків (в `watch_gui.py`) використовується інший підхід — генерація інкрементальних значень (1-7 кроків) кожні 5 секунд, які відправляються як окремі телеметрії, а не накопичувальні значення.

#### 5.1.3. Генерація даних про сон

Метод `generate_sleep_data()` створює структуровані дані про сон з реалістичними параметрами:

```python
def generate_sleep_data(self, date: datetime) -> Dict:
    # Загальний час сну: 6-9 годин (360-540 хвилин)
    total_sleep = random.randint(360, 540)
    
    # Глибокий сон: 15-25% від загального
    deep_sleep_percent = random.uniform(0.15, 0.25)
    deep_sleep = int(total_sleep * deep_sleep_percent)
    
    # Легкий сон: 50-70% від загального
    light_sleep_percent = random.uniform(0.50, 0.70)
    light_sleep = int(total_sleep * light_sleep_percent)
    
    # Час біля: решта
    awake = total_sleep - deep_sleep - light_sleep
    
    # Якість сну: 70-95%
    quality = random.uniform(70.0, 95.0)
    
    # Час засинання: 22:00-22:30
    start_time = date.replace(hour=22, minute=random.randint(0, 30), second=0, microsecond=0)
    
    # Час пробудження: startTime + totalSleepMinutes
    end_time = start_time + timedelta(minutes=total_sleep)
    
    return {
        "date": date.date().isoformat(),
        "totalSleepMinutes": total_sleep,
        "deepSleepMinutes": deep_sleep,
        "lightSleepMinutes": light_sleep,
        "awakeMinutes": awake,
        "sleepQuality": round(quality, 1),
        "startTime": start_time.isoformat(),
        "endTime": end_time.isoformat()
    }
```

**Логіка роботи:**
1. **Загальний час сну:** Генерується випадкове значення від 360 до 540 хвилин (6-9 годин)
2. **Розподіл фаз сну:**
   - Глибокий сон: 15-25% від загального часу
   - Легкий сон: 50-70% від загального часу
   - Час біля: решта часу (різниця між загальним та фазами)
3. **Якість сну:** Випадкове значення від 70% до 95%
4. **Часові рамки:**
   - Час засинання: 22:00-22:30
   - Час пробудження: розраховується як `start_time + total_sleep`

**Формат даних:** Метод повертає словник у форматі, сумісному з API сервера, включаючи ISO формат дат та часу.

#### 5.1.4. Обробка та валідація даних

Клас `SensorSimulator` не виконує валідацію даних, оскільки він призначений тільки для генерації. Валідація виконується на рівні API клієнта перед відправкою на сервер.

### 5.2. Реалізація комунікації з сервером через HTTP протокол

Система використовує HTTP протокол для комунікації з серверною частиною. Реалізовано модульну архітектуру API клієнтів з централізованою обробкою помилок та повторними спробами.

#### 5.2.1. Базовий API клієнт (BaseApiClient)

**Файл:** `src/base_api_client.py`

Базовий клас `BaseApiClient` містить спільну логіку для всіх API клієнтів:

**Ініціалізація та конфігурація:**
```python
def __init__(self, config_manager: ConfigManager):
    config = config_manager.load_config()
    
    # Налаштування сервера
    self.base_url = config['server']['base_url'].rstrip('/')
    self.timeout = config['server']['timeout']
    self.retry_attempts = config['server']['retry_attempts']
    self.retry_delay = config['server']['retry_delay']
    
    # Параметри пристрою
    self.device_id = config['device']['device_id']
    self.user_id = config['device']['user_id']
    
    # Створення HTTP сесії (для перевикористання з'єднань)
    self.session = requests.Session()
    self.session.headers.update({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    })
```

**Особливості:**
- Використання `requests.Session()` для перевикористання TCP з'єднань (оптимізація продуктивності)
- Централізоване налаштування заголовків HTTP (Content-Type, Accept)
- Завантаження параметрів з конфігурації (URL, таймаути, ID пристрою)

**Метод `_make_request()` — центральна логіка HTTP запитів:**

```python
def _make_request(self, method: str, url: str, payload: Optional[Dict] = None, 
                 params: Optional[Dict] = None) -> Optional[requests.Response]:
    """Виконує HTTP запит з повторними спробами при помилках"""
    last_error = None
    
    for attempt in range(1, self.retry_attempts + 1):
        try:
            # Виконання HTTP запиту залежно від методу
            if method.upper() == 'GET':
                response = self.session.get(url, params=params, timeout=self.timeout)
            elif method.upper() == 'POST':
                response = self.session.post(url, json=payload, timeout=self.timeout)
            elif method.upper() == 'PUT':
                response = self.session.put(url, json=payload, timeout=self.timeout)
            elif method.upper() == 'DELETE':
                response = self.session.delete(url, timeout=self.timeout)
            
            # Перевірка статусу відповіді
            response.raise_for_status()
            return response
            
        except requests.exceptions.Timeout:
            # Обробка таймауту
            last_error = f"Таймаут запиту (більше {self.timeout} секунд)"
            if attempt < self.retry_attempts:
                time.sleep(self.retry_delay)
                
        except requests.exceptions.ConnectionError:
            # Обробка помилок підключення
            last_error = "Помилка підключення до сервера"
            if attempt < self.retry_attempts:
                time.sleep(self.retry_delay)
                
        except requests.exceptions.HTTPError as e:
            # HTTP помилки (4xx, 5xx) не повторюємо
            last_error = f"HTTP помилка {e.response.status_code}: {e.response.text}"
            return None
            
        except Exception as e:
            # Інші помилки
            last_error = f"Невідома помилка: {str(e)}"
            if attempt < self.retry_attempts:
                time.sleep(self.retry_delay)
    
    # Всі спроби не вдалися
    return None
```

**Логіка обробки помилок:**
1. **Таймаути** — автоматичні повторні спроби з затримкою
2. **Помилки підключення** — повторні спроби при відсутності інтернету або недоступності сервера
3. **HTTP помилки (4xx, 5xx)** — не повторюються (логічні помилки, не мережеві)
4. **Інші помилки** — повторні спроби з логуванням

**Механізм повторних спроб:**
- Кількість спроб: налаштовується через `retry_attempts` (за замовчуванням 3)
- Затримка між спробами: налаштовується через `retry_delay` (за замовчуванням 5 секунд)
- Логування: кожна спроба логується з номером спроби та типом помилки

#### 5.2.2. Клієнт для телеметрії (TelemetryApiClient)

**Файл:** `src/telemetry_api_client.py`

Реалізує відправку телеметрії на сервер через HTTP POST запити.

**Метод `send_telemetry()` — відправка одиночного значення:**

```python
def send_telemetry(self, telemetry_type: int, value: float, 
                  timestamp: datetime, metadata: Optional[Dict] = None) -> bool:
    url = f"{self.base_url}/api/telemetry/receive"
    
    payload = {
        "deviceId": self.device_id,
        "timestamp": timestamp.isoformat(),
        "telemetryType": telemetry_type,  # 0=HeartRate, 1=Steps
        "value": float(value),
        "metadata": metadata
    }
    
    response = self._make_request('POST', url, payload=payload)
    return response is not None
```

**Логіка роботи:**
- Формує JSON payload з даними телеметрії
- Використовує ISO формат для timestamp
- `telemetryType`: 0 для пульсу, 1 для кроків
- Повертає `True` при успішній відправці, `False` при помилці

**Метод `send_sleep_record()` — відправка даних про сон:**

```python
def send_sleep_record(self, sleep_data: Dict) -> bool:
    url = f"{self.base_url}/api/SleepRecords"
    
    payload = {
        "deviceId": self.device_id,
        **sleep_data  # Розпаковуємо всі дані про сон
    }
    
    # Конвертуємо datetime об'єкти в ISO формат
    if 'date' in payload and isinstance(payload['date'], datetime):
        payload['date'] = payload['date'].date().isoformat()
    if 'startTime' in payload and isinstance(payload['startTime'], datetime):
        payload['startTime'] = payload['startTime'].isoformat()
    if 'endTime' in payload and isinstance(payload['endTime'], datetime):
        payload['endTime'] = payload['endTime'].isoformat()
    
    response = self._make_request('POST', url, payload=payload)
    return response is not None
```

**Особливості:**
- Автоматична конвертація datetime об'єктів в ISO формат
- Додавання `deviceId` до даних про сон
- Валідація та обробка різних форматів дат

#### 5.2.3. Клієнт для планів дієти (DietApiClient)

**Файл:** `src/diet_api_client.py`

Реалізує отримання планів дієти з сервера через HTTP GET запити.

**Метод `get_daily_diet_plans()` — отримання списку планів:**

```python
def get_daily_diet_plans(self, user_id: Optional[int] = None) -> List[Dict]:
    if user_id is None:
        user_id = self.user_id
    
    url = f"{self.base_url}/api/dailydietplans"
    params = {"userId": user_id}
    
    response = self._make_request('GET', url, params=params)
    
    if response:
        plans = response.json()
        return plans if isinstance(plans, list) else []
    return []
```

**Логіка роботи:**
- Використовує GET запит з параметром `userId` для фільтрації
- Парсить JSON відповідь
- Валідує, що відповідь є списком
- Повертає порожній список при помилці

**Метод `get_daily_diet_plan()` — отримання деталей плану:**

```python
def get_daily_diet_plan(self, plan_id: int) -> Optional[Dict]:
    url = f"{self.base_url}/api/dailydietplans/{plan_id}/meals"
    
    response = self._make_request('GET', url)
    
    if response:
        return response.json()
    return None
```

**Особливості:**
- Використовує RESTful API з ID плану в URL
- Повертає деталі плану з прийомами їжі та рецептами

#### 5.2.4. Інші API клієнти

**StatisticsApiClient** (`src/statistics_api_client.py`):
- `get_daily_statistics()` — GET запит до `/api/statistics/daily` з параметрами `date` та `userId`
- `get_weekly_statistics()` — GET запит до `/api/statistics/weekly` з параметрами `startDate` та `userId`

**UserApiClient** (`src/user_api_client.py`):
- `get_user_profile()` — GET запит до `/api/userprofiles/{user_id}` для отримання профілю користувача

**RecommendationsApiClient** (`src/recommendations_api_client.py`):
- `get_recommendations()` — GET запит до `/api/recommendations` з параметром `userId`

#### 5.2.5. Головний API клієнт (ApiClient)

**Файл:** `src/api_client.py`

Клас `ApiClient` об'єднує всі спеціалізовані клієнти через множинне наслідування:

```python
class ApiClient(TelemetryApiClient, DietApiClient, StatisticsApiClient, 
                UserApiClient, RecommendationsApiClient):
    """Головний API клієнт, який об'єднує всі модулі"""
    
    def __init__(self, config_manager: ConfigManager):
        BaseApiClient.__init__(self, config_manager)
```

**Переваги архітектури:**
- Один об'єкт для роботи з усіма API endpoints
- Модульність — кожен клієнт відповідає за свою область
- Перевикористання коду — спільна логіка в базовому класі
- Легке розширення — додавання нових клієнтів не вимагає змін існуючого коду

### 5.3. Реалізація функцій налаштування IoT клієнта

**Файл:** `src/config_manager.py`

Клас `ConfigManager` реалізує повноцінне управління конфігурацією системи через JSON файли. Конфігурація містить налаштування сервера, параметри пристрою, інтервали датчиків та параметри обробки даних.

#### 5.3.1. Структура конфігурації

Конфігурація організована в логічні секції:

```json
{
  "server": {
    "base_url": "http://localhost:5006",
    "timeout": 10,
    "retry_attempts": 3,
    "retry_delay": 5
  },
  "device": {
    "device_id": 1,
    "user_id": 1,
    "device_type": "FitnessTracker",
    "connection_type": "WiFi"
  },
  "sensors": {
    "heart_rate_interval": 5,
    "steps_interval": 5,
    "blood_pressure_interval": 600
  },
  "data": {
    "batch_size": 5,
    "send_interval": 15
  },
  "logging": {
    "level": "INFO",
    "file": "logs/iot_client.log"
  }
}
```

#### 5.3.2. Завантаження конфігурації

Метод `load_config()` реалізує інтелектуальне завантаження конфігурації:

```python
def load_config(self) -> Dict:
    # 1. Спочатку завантажуємо дефолтну конфігурацію з файлу
    if os.path.exists(self.default_config_path):
        with open(self.default_config_path, 'r', encoding='utf-8') as f:
            default_from_file = json.load(f)
            self.default_config = self._merge_dicts(self.default_config, default_from_file)
    
    # 2. Завантажуємо користувацьку конфігурацію
    if os.path.exists(self.config_path):
        with open(self.config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
            # 3. Об'єднуємо з дефолтними (для нових полів)
            merged_config = self._merge_dicts(self.default_config, config)
            return merged_config
    
    # 4. Якщо файл не існує - використовуємо дефолти
    return self.default_config.copy()
```

**Логіка роботи:**
1. Завантаження дефолтної конфігурації з `config.default.json` (якщо існує)
2. Завантаження користувацької конфігурації з `config.json` (якщо існує)
3. Рекурсивне об'єднання конфігурацій (користувацькі значення мають пріоритет)
4. Fallback на вбудовані дефолти, якщо файли не існують

**Переваги:**
- Автоматичне додавання нових полів з дефолтної конфігурації
- Збереження користувацьких налаштувань при оновленні системи
- Безпечне обробка помилок парсингу JSON

#### 5.3.3. Збереження конфігурації

Метод `save_config()` зберігає конфігурацію у файл:

```python
def save_config(self, config: Dict):
    # Створити папку config/ якщо не існує
    config_dir = os.path.dirname(self.config_path)
    if config_dir and not os.path.exists(config_dir):
        os.makedirs(config_dir, exist_ok=True)
    
    with open(self.config_path, 'w', encoding='utf-8') as f:
        json.dump(config, f, indent=2, ensure_ascii=False)
```

**Особливості:**
- Автоматичне створення директорії `config/` якщо не існує
- Форматування JSON з відступами для читабельності
- Підтримка Unicode символів (`ensure_ascii=False`)

#### 5.3.4. Оновлення окремих параметрів

Метод `update_setting()` дозволяє оновити конкретний параметр:

```python
def update_setting(self, section: str, key: str, value):
    config = self.load_config()
    
    if section in config:
        if key in config[section]:
            config[section][key] = value
            self.save_config(config)
        else:
            print(f"Ключ '{key}' не знайдено в секції '{section}'")
    else:
        print(f"Секція '{section}' не знайдена в конфігурації")
```

**Використання:**
```python
config_manager.update_setting("server", "base_url", "http://localhost:5006")
config_manager.update_setting("device", "device_id", 2)
```

#### 5.3.5. Скидання до дефолтних значень

Метод `reset_to_defaults()` відновлює початкові налаштування:

```python
def reset_to_defaults(self):
    default_config = self.load_config()  # Завантажує дефолти
    self.save_config(default_config)     # Перезаписує config.json
```

**Використання:** Корисно при налагодженні або після помилок конфігурації.

#### 5.3.6. Рекурсивне об'єднання словників

Метод `_merge_dicts()` реалізує рекурсивне об'єднання вкладених словників:

```python
def _merge_dicts(self, default: Dict, user: Dict) -> Dict:
    result = default.copy()
    
    for key, value in user.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            # Рекурсивне об'єднання для вкладених словників
            result[key] = self._merge_dicts(result[key], value)
        else:
            # Заміна значення
            result[key] = value
    
    return result
```

**Логіка:** Дозволяє частково оновлювати конфігурацію, зберігаючи інші параметри.

### 5.4. Реалізація локальної обробки даних

**Файл:** `src/statistics_calculator.py`

Клас `StatisticsCalculator` виконує локальну агрегацію та обчислення статистики на клієнті перед відправкою на сервер або для відображення в GUI.

#### 5.4.1. Зберігання даних

Клас зберігає дані в пам'яті для локальної обробки:

```python
def __init__(self):
    self.heart_rate_samples = []  # [(timestamp, value), ...]
    self.steps_samples = []       # [(timestamp, value), ...]
    self.sleep_records = []       # [sleep_data_dict, ...]
    self.daily_steps_accumulator = {}  # {date_str: last_cumulative_value}
```

**Структура даних:**
- `heart_rate_samples` — список кортежів (timestamp, value) для пульсу
- `steps_samples` — список кортежів (timestamp, value) для кроків
- `sleep_records` — список словників з даними про сон
- `daily_steps_accumulator` — накопичувач кроків по днях

#### 5.4.2. Додавання даних

Методи `add_heart_rate()`, `add_steps()`, `add_sleep_record()` додають нові дані:

```python
def add_steps(self, value: int, timestamp: datetime):
    date_str = timestamp.date().isoformat()
    
    if date_str in self.daily_steps_accumulator:
        last_value = self.daily_steps_accumulator[date_str]
        if value >= last_value:
            # Накопичувальне значення
            self.daily_steps_accumulator[date_str] = value
        else:
            # Інкрементальне значення
            self.daily_steps_accumulator[date_str] = last_value + value
    else:
        self.daily_steps_accumulator[date_str] = value
    
    self.steps_samples.append((timestamp, self.daily_steps_accumulator[date_str]))
```

**Логіка обробки кроків:**
- Підтримка як накопичувальних, так і інкрементальних значень
- Автоматичне визначення типу значення (якщо нове значення менше попереднього — інкремент)
- Накопичення по дням для коректного підрахунку загальної кількості

#### 5.4.3. Обчислення статистики

Метод `get_daily_heart_rate_stats()` обчислює статистику пульсу за день:

```python
def get_daily_heart_rate_stats(self, date: datetime) -> Optional[Dict]:
    date_start = date.replace(hour=0, minute=0, second=0, microsecond=0)
    date_end = date_start + timedelta(days=1)
    
    # Фільтрація зразків за датою
    day_samples = [
        value for ts, value in self.heart_rate_samples
        if date_start <= ts < date_end
    ]
    
    if not day_samples:
        return None
    
    return {
        "date": date.date().isoformat(),
        "count": len(day_samples),
        "min": float(min(day_samples)),
        "max": float(max(day_samples)),
        "avg": float(statistics.mean(day_samples)),
        "median": float(statistics.median(day_samples))
    }
```

**Обчислювані показники:**
- Кількість зразків (`count`)
- Мінімальне значення (`min`)
- Максимальне значення (`max`)
- Середнє значення (`avg`)
- Медіана (`median`)

#### 5.4.4. Обчислення трендів

Метод `get_weekly_heart_rate_trend()` обчислює тренди за тиждень:

```python
def get_weekly_heart_rate_trend(self, start_date: datetime) -> Optional[Dict]:
    week_data = []
    
    for day_offset in range(7):
        current_date = start_date + timedelta(days=day_offset)
        day_stats = self.get_daily_heart_rate_stats(current_date)
        if day_stats:
            week_data.append(day_stats["avg"])
    
    if len(week_data) < 2:
        return None
    
    # Обчислення тренду (зростання/зниження)
    first_half = statistics.mean(week_data[:len(week_data)//2])
    second_half = statistics.mean(week_data[len(week_data)//2:])
    
    trend_percent = ((second_half - first_half) / first_half * 100) if first_half > 0 else 0
    
    return {
        "startDate": start_date.date().isoformat(),
        "endDate": (start_date + timedelta(days=6)).date().isoformat(),
        "avg": float(statistics.mean(week_data)),
        "trendPercent": round(trend_percent, 2)
    }
```

**Логіка обчислення тренду:**
- Збір даних за 7 днів
- Розділення на першу та другу половину тижня
- Обчислення відсотка зміни між половинами
- Повернення середнього значення та тренду

### 5.5. Загальна логіка системи та інтеграція компонентів

Система реалізована з чітким розділенням відповідальності між компонентами та централізованою обробкою даних.

#### 5.5.1. Потік обробки даних з датчиків

**Сценарій 1: Вимірювання пульсу (ручне)**

```
1. Користувач натискає кнопку "Виміряти пульс" в GUI
   ↓
2. WatchGUI.measure_heart_rate() викликає SensorSimulator.read_heart_rate()
   ↓
3. SensorSimulator генерує випадкове значення 60-100 bpm
   ↓
4. WatchGUI викликає ApiClient.send_telemetry(0, hr, now)
   ↓
5. TelemetryApiClient формує HTTP POST запит до /api/telemetry/receive
   ↓
6. BaseApiClient._make_request() виконує запит з повторними спробами
   ↓
7. При успішній відправці:
   - StatisticsCalculator.add_heart_rate() додає дані до локальної статистики
   - GUI оновлює відображення
   - Логується результат
```

**Сценарій 2: Автоматична симуляція кроків**

```
1. Користувач натискає "Запустити симуляцію кроків"
   ↓
2. WatchGUI.start_simulation() створює окремий потік
   ↓
3. simulation_loop() працює в циклі:
   - Чекає інтервал (5 секунд за замовчуванням)
   - Генерує 1-7 кроків (random.randint(1, 7))
   - Викликає ApiClient.send_telemetry(1, steps, now)
   - Оновлює локальну статистику
   - Логує результат
   ↓
4. При зупинці симуляції потік завершується
```

**Сценарій 3: Відправка даних про сон**

```
1. Користувач натискає "Відправити дані про сон"
   ↓
2. WatchGUI.send_sleep_data() викликає SensorSimulator.generate_sleep_data()
   ↓
3. SensorSimulator генерує структуровані дані:
   - totalSleepMinutes: 360-540
   - deepSleepMinutes: 15-25% від загального
   - lightSleepMinutes: 50-70% від загального
   - sleepQuality: 70-95%
   ↓
4. WatchGUI викликає ApiClient.send_sleep_record(sleep_data)
   ↓
5. TelemetryApiClient формує HTTP POST запит до /api/SleepRecords
   ↓
6. При успішній відправці:
   - StatisticsCalculator.add_sleep_record() додає дані
   - GUI оновлює відображення
```

#### 5.5.2. Потік отримання даних з сервера

**Сценарій: Завантаження плану дієти**

```
1. Користувач натискає "Завантажити план дієти"
   ↓
2. WatchGUI.load_diet_plan() викликає ApiClient.get_daily_diet_plans(user_id)
   ↓
3. DietApiClient виконує GET запит до /api/dailydietplans?userId={user_id}
   ↓
4. Сервер повертає список планів, відсортований за датою
   ↓
5. WatchGUI вибирає найновіший план (перший в списку)
   ↓
6. WatchGUI викликає ApiClient.get_daily_diet_plan(plan_id)
   ↓
7. DietApiClient виконує GET запит до /api/dailydietplans/{plan_id}/meals
   ↓
8. Сервер повертає деталі плану з прийомами їжі
   ↓
9. Для кожного прийому їжі:
   - Завантажуються рецепти через ApiClient.get_recipe(recipe_id)
   - Завантажується профіль користувача через ApiClient.get_user_profile(user_id)
   ↓
10. WatchGUI відображає всі дані в текстовому полі
```

#### 5.5.3. Обробка помилок та повторні спроби

**Механізм повторних спроб:**

```python
# У BaseApiClient._make_request()
for attempt in range(1, self.retry_attempts + 1):
    try:
        response = self.session.post(url, json=payload, timeout=self.timeout)
        response.raise_for_status()
        return response
    except requests.exceptions.Timeout:
        if attempt < self.retry_attempts:
            time.sleep(self.retry_delay)  # Затримка перед повторною спробою
    except requests.exceptions.ConnectionError:
        if attempt < self.retry_attempts:
            time.sleep(self.retry_delay)
    except requests.exceptions.HTTPError:
        return None  # HTTP помилки не повторюються
```

**Типи помилок та обробка:**

1. **Таймаути** — повторні спроби з затримкою
2. **Помилки підключення** — повторні спроби (відсутність інтернету, сервер недоступний)
3. **HTTP помилки (4xx, 5xx)** — не повторюються, логуються та повертаються в GUI
4. **Інші помилки** — повторні спроби з логуванням

**Відображення помилок в GUI:**
- Помилки логуються в текстове поле на вкладці "Датчики"
- Червоний колір для міток помилок
- Повідомлення про тип помилки та час виникнення

#### 5.5.4. Багатопотоковість

Система використовує багатопотоковість для неблокуючої роботи GUI:

```python
# У WatchGUI.start_simulation()
self.simulation_thread = threading.Thread(target=self.simulation_loop, daemon=True)
self.simulation_thread.start()
```

**Особливості:**
- Потік симуляції працює як daemon (завершується з основним процесом)
- GUI залишається відзивчивим під час симуляції
- Безпечне завершення потоку при закритті додатку

#### 5.5.5. Ініціалізація системи

**Файл:** `src/main.py`

Функція `main()` реалізує послідовну ініціалізацію всіх компонентів:

```python
def main():
    # 1. Створення менеджера конфігурації
    config_manager = ConfigManager()
    
    # 2. Створення API клієнта (завантажує конфігурацію)
    api_client = ApiClient(config_manager)
    
    # 3. Створення симулятора датчиків
    sensor_simulator = SensorSimulator()
    
    # 4. Створення калькулятора статистики
    stats_calculator = StatisticsCalculator()
    
    # 5. Створення та запуск GUI (передаємо всі компоненти)
    gui = WatchGUI(api_client, sensor_simulator, stats_calculator, config_manager)
    gui.run()  # Запускає Tkinter event loop
```

**Залежності між компонентами:**
- `ConfigManager` → `ApiClient` (завантажує налаштування)
- `ApiClient` → `WatchGUI` (для відправки/отримання даних)
- `SensorSimulator` → `WatchGUI` (для генерації даних)
- `StatisticsCalculator` → `WatchGUI` (для локальної статистики)

### 5.6. Графічний інтерфейс користувача

**Файл:** `src/watch_gui.py`

Клас `WatchGUI` реалізує повноцінний GUI на базі Tkinter з п'ятьма вкладками:

1. **Головна** — поточний час, пульс, кроки, бал активності, кнопка оновлення
2. **Дієта** — завантаження та відображення плану дієти з профілем користувача
3. **Рекомендації** — список рекомендацій від сервера
4. **Статистика** — денна та тижнева статистика з деталізацією
5. **Датчики** — управління симуляцією:
   - Кнопка "Виміряти пульс" (on-demand)
   - Кнопки запуску/зупинки симуляції кроків
   - Кнопка відправки даних про сон
   - Логи всіх операцій

**Особливості реалізації:**
- Багатопотоковість для симуляції (не блокує GUI)
- Автоматичне оновлення часу кожну секунду
- Детальне логування всіх операцій в текстове поле
- Обробка помилок з відображенням повідомлень користувачу
- Валідація даних перед відправкою на сервер
- Сортування планів дієти за датою для вибору найновішого

### 5.7. Підсумок реалізації

**Реалізовані компоненти:**

✅ **Обробка даних з датчиків:**
- Генерація пульсу (60-100 bpm)
- Генерація інкрементальних кроків (1-7 за раз)
- Генерація структурованих даних про сон

✅ **Комунікація з сервером через HTTP:**
- RESTful API з підтримкою GET, POST, PUT, DELETE
- Автоматичні повторні спроби при мережевих помилках
- Обробка таймаутів та HTTP помилок
- Використання HTTP сесій для оптимізації

✅ **Функції налаштування:**
- Завантаження/збереження конфігурації з JSON
- Оновлення окремих параметрів
- Скидання до дефолтних значень
- Рекурсивне об'єднання конфігурацій

✅ **Локальна обробка даних:**
- Агрегація телеметрії
- Обчислення статистики (min, max, avg, median)
- Обчислення трендів за тиждень
- Накопичення даних по днях

✅ **Графічний інтерфейс:**
- П'ять вкладок для різних функцій
- Багатопотокова симуляція
- Детальне логування
- Обробка помилок з відображенням користувачу

---

## 6. Перевірка роботи IoT клієнта

### 6.1. Тестування компонентів

**6.1.1. Тестування ConfigManager:**
- Перевірка завантаження дефолтної конфігурації
- Перевірка збереження змінених налаштувань
- Перевірка скидання до дефолтів

**6.1.2. Тестування SensorSimulator:**
- Генерація пульсу в правильному діапазоні
- Генерація інкрементальних кроків
- Генерація реалістичних даних про сон

**6.1.3. Тестування API клієнтів:**
- Відправка телеметрії на сервер
- Завантаження планів дієти
- Завантаження статистики
- Обробка помилок мережі

**Файли тестів:** `tests/test_api_client.py`, `tests/test_sensor_simulator.py`

### 6.2. Перевірка коректності обміну даними з сервером

**Відправка даних:**
- ✅ Пульс відправляється коректно (перевірено через Swagger та логи сервера)
- ✅ Кроки відправляються кожні 5 секунд як окремі телеметрії
- ✅ Дані про сон відправляються у правильному форматі

**Отримання даних:**
- ✅ Плани дієти завантажуються та відображаються коректно
- ✅ Вибирається найновіший план (сортування за датою)
- ✅ Профіль користувача відображається разом з планом
- ✅ Рекомендації завантажуються та відображаються
- ✅ Статистика (денна/тижнева) завантажується та відображається з усіма деталями

### 6.3. Функціональність налаштувань

- ✅ Конфігурація завантажується з файлу або використовуються дефолти
- ✅ Зміни конфігурації зберігаються
- ✅ Скидання до дефолтів працює коректно
- ✅ Всі параметри (URL сервера, ID пристрою, інтервали) налаштовуються через конфіг

### 6.4. Стабільність роботи

- ✅ Симуляція працює без блокування GUI (багатопотоковість)
- ✅ Обробка помилок мережі (повторні спроби, відображення помилок)
- ✅ GUI не зависає при довгих операціях
- ✅ Логування допомагає діагностувати проблеми

### 6.5. Інтеграція з сервером

Проведено повну інтеграцію з існуючим .NET сервером:
- Всі API endpoints працюють коректно
- Дані синхронізуються між клієнтом та сервером
- Фільтрація планів дієти за user_id працює
- Сортування планів за датою реалізовано на сервері та клієнті

---

## Висновки

У ході виконання лабораторної роботи було успішно розроблено повнофункціональний IoT клієнт для системи фітнес-трекінгу. Реалізовано:

1. ✅ Модульну архітектуру з чітким розділенням відповідальності
2. ✅ UML діаграми (прецедентів та діяльності)
3. ✅ Повну бізнес-логіку для роботи з датчиками та сервером
4. ✅ Гнучке управління конфігурацією
5. ✅ Графічний інтерфейс користувача
6. ✅ Стабільну роботу та обробку помилок
7. ✅ Успішну інтеграцію з серверною частиною

Система готова до використання та може бути легко розширена додатковими функціями.

